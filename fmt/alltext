0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 typedef __SIZE_TYPE__ size_t;
0105 #define NULL ((void*)0)
0106 #define MAX_LINE_LENGTH 1024
0107 #define MAX_LINES 256
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 #define V2P(a) (((uint) (a)) - KERNBASE)
0211 #define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
0212 
0213 #define V2P_WO(x) ((x) - KERNBASE)    
0214 #define P2V_WO(x) ((x) + KERNBASE)    
0215 
0216 
0217 
0218 
0219 
0220 
0221 
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct sleeplock;
0259 struct stat;
0260 struct superblock;
0261 
0262 
0263 void            binit(void);
0264 struct buf*     bread(uint, uint);
0265 void            brelse(struct buf*);
0266 void            bwrite(struct buf*);
0267 
0268 
0269 void            consoleinit(void);
0270 void            cprintf(char*, ...);
0271 void            consoleintr(int(*)(void));
0272 void            panic(char*) __attribute__((noreturn));
0273 
0274 
0275 int             exec(char*, char**);
0276 
0277 
0278 struct file*    filealloc(void);
0279 void            fileclose(struct file*);
0280 struct file*    filedup(struct file*);
0281 void            fileinit(void);
0282 int             fileread(struct file*, char*, int n);
0283 int             filestat(struct file*, struct stat*);
0284 int             filewrite(struct file*, char*, int n);
0285 
0286 
0287 void            readsb(int dev, struct superblock *sb);
0288 int             dirlink(struct inode*, char*, uint);
0289 struct inode*   dirlookup(struct inode*, char*, uint*);
0290 struct inode*   ialloc(uint, short);
0291 struct inode*   idup(struct inode*);
0292 void            iinit(int dev);
0293 void            ilock(struct inode*);
0294 void            iput(struct inode*);
0295 void            iunlock(struct inode*);
0296 void            iunlockput(struct inode*);
0297 void            iupdate(struct inode*);
0298 int             namecmp(const char*, const char*);
0299 struct inode*   namei(char*);
0300 struct inode*   nameiparent(char*, char*);
0301 int             readi(struct inode*, char*, uint, uint);
0302 void            stati(struct inode*, struct stat*);
0303 int             writei(struct inode*, char*, uint, uint);
0304 
0305 
0306 void            ideinit(void);
0307 void            ideintr(void);
0308 void            iderw(struct buf*);
0309 
0310 
0311 void            ioapicenable(int irq, int cpu);
0312 extern uchar    ioapicid;
0313 void            ioapicinit(void);
0314 
0315 
0316 char*           kalloc(void);
0317 void            kfree(char*);
0318 void            kinit1(void*, void*);
0319 void            kinit2(void*, void*);
0320 
0321 
0322 void            kbdintr(void);
0323 
0324 
0325 void            cmostime(struct rtcdate *r);
0326 int             lapicid(void);
0327 extern volatile uint*    lapic;
0328 void            lapiceoi(void);
0329 void            lapicinit(void);
0330 void            lapicstartap(uchar, uint);
0331 void            microdelay(int);
0332 
0333 
0334 void            initlog(int dev);
0335 void            log_write(struct buf*);
0336 void            begin_op();
0337 void            end_op();
0338 
0339 
0340 extern int      ismp;
0341 void            mpinit(void);
0342 
0343 
0344 void            picenable(int);
0345 void            picinit(void);
0346 
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 
0358 int             cpuid(void);
0359 void            exit(void);
0360 int             fork(void);
0361 int             growproc(int);
0362 int             kill(int);
0363 struct cpu*     mycpu(void);
0364 struct proc*    myproc();
0365 void            pinit(void);
0366 void            procdump(void);
0367 void            scheduler(void) __attribute__((noreturn));
0368 void            sched(void);
0369 void            setproc(struct proc*);
0370 void            sleep(void*, struct spinlock*);
0371 void            userinit(void);
0372 int             wait(void);
0373 void            wakeup(void*);
0374 void            yield(void);
0375 
0376 
0377 void            swtch(struct context**, struct context*);
0378 
0379 
0380 void            acquire(struct spinlock*);
0381 void            getcallerpcs(void*, uint*);
0382 int             holding(struct spinlock*);
0383 void            initlock(struct spinlock*, char*);
0384 void            release(struct spinlock*);
0385 void            pushcli(void);
0386 void            popcli(void);
0387 
0388 
0389 void            acquiresleep(struct sleeplock*);
0390 void            releasesleep(struct sleeplock*);
0391 int             holdingsleep(struct sleeplock*);
0392 void            initsleeplock(struct sleeplock*, char*);
0393 
0394 
0395 int             memcmp(const void*, const void*, uint);
0396 void*           memmove(void*, const void*, uint);
0397 void*           memset(void*, int, uint);
0398 char*           safestrcpy(char*, const char*, int);
0399 int             strlen(const char*);
0400 int             strncmp(const char*, const char*, uint);
0401 char*           strncpy(char*, const char*, int);
0402 
0403 
0404 int             argint(int, int*);
0405 int             argptr(int, char**, int);
0406 int             argstr(int, char**);
0407 int             fetchint(uint, int*);
0408 int             fetchstr(uint, char**);
0409 void            syscall(void);
0410 
0411 
0412 void            timerinit(void);
0413 
0414 
0415 void            idtinit(void);
0416 extern uint     ticks;
0417 void            tvinit(void);
0418 extern struct spinlock tickslock;
0419 
0420 
0421 void            uartinit(void);
0422 void            uartintr(void);
0423 void            uartputc(int);
0424 
0425 
0426 void            seginit(void);
0427 void            kvmalloc(void);
0428 pde_t*          setupkvm(void);
0429 char*           uva2ka(pde_t*, char*);
0430 int             allocuvm(pde_t*, uint, uint);
0431 int             deallocuvm(pde_t*, uint, uint);
0432 void            freevm(pde_t*);
0433 void            inituvm(pde_t*, char*, uint);
0434 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0435 pde_t*          copyuvm(pde_t*, uint);
0436 void            switchuvm(struct proc*);
0437 void            switchkvm(void);
0438 int             copyout(pde_t*, uint, void*, uint);
0439 void            clearpteu(pde_t *pgdir, char *uva);
0440 
0441 
0442 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0443 
0444 
0445 
0446 
0447 
0448 
0449 
0450 
0451 
0452 static inline uchar
0453 inb(ushort port)
0454 {
0455   uchar data;
0456 
0457   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0458   return data;
0459 }
0460 
0461 static inline void
0462 insl(int port, void *addr, int cnt)
0463 {
0464   asm volatile("cld; rep insl" :
0465                "=D" (addr), "=c" (cnt) :
0466                "d" (port), "0" (addr), "1" (cnt) :
0467                "memory", "cc");
0468 }
0469 
0470 static inline void
0471 outb(ushort port, uchar data)
0472 {
0473   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0474 }
0475 
0476 static inline void
0477 outw(ushort port, ushort data)
0478 {
0479   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0480 }
0481 
0482 static inline void
0483 outsl(int port, const void *addr, int cnt)
0484 {
0485   asm volatile("cld; rep outsl" :
0486                "=S" (addr), "=c" (cnt) :
0487                "d" (port), "0" (addr), "1" (cnt) :
0488                "cc");
0489 }
0490 
0491 static inline void
0492 stosb(void *addr, int data, int cnt)
0493 {
0494   asm volatile("cld; rep stosb" :
0495                "=D" (addr), "=c" (cnt) :
0496                "0" (addr), "1" (cnt), "a" (data) :
0497                "memory", "cc");
0498 }
0499 
0500 static inline void
0501 stosl(void *addr, int data, int cnt)
0502 {
0503   asm volatile("cld; rep stosl" :
0504                "=D" (addr), "=c" (cnt) :
0505                "0" (addr), "1" (cnt), "a" (data) :
0506                "memory", "cc");
0507 }
0508 
0509 struct segdesc;
0510 
0511 static inline void
0512 lgdt(struct segdesc *p, int size)
0513 {
0514   volatile ushort pd[3];
0515 
0516   pd[0] = size-1;
0517   pd[1] = (uint)p;
0518   pd[2] = (uint)p >> 16;
0519 
0520   asm volatile("lgdt (%0)" : : "r" (pd));
0521 }
0522 
0523 struct gatedesc;
0524 
0525 static inline void
0526 lidt(struct gatedesc *p, int size)
0527 {
0528   volatile ushort pd[3];
0529 
0530   pd[0] = size-1;
0531   pd[1] = (uint)p;
0532   pd[2] = (uint)p >> 16;
0533 
0534   asm volatile("lidt (%0)" : : "r" (pd));
0535 }
0536 
0537 static inline void
0538 ltr(ushort sel)
0539 {
0540   asm volatile("ltr %0" : : "r" (sel));
0541 }
0542 
0543 static inline uint
0544 readeflags(void)
0545 {
0546   uint eflags;
0547   asm volatile("pushfl; popl %0" : "=r" (eflags));
0548   return eflags;
0549 }
0550 static inline void
0551 loadgs(ushort v)
0552 {
0553   asm volatile("movw %0, %%gs" : : "r" (v));
0554 }
0555 
0556 static inline void
0557 cli(void)
0558 {
0559   asm volatile("cli");
0560 }
0561 
0562 static inline void
0563 sti(void)
0564 {
0565   asm volatile("sti");
0566 }
0567 
0568 static inline uint
0569 xchg(volatile uint *addr, uint newval)
0570 {
0571   uint result;
0572 
0573   
0574   asm volatile("lock; xchgl %0, %1" :
0575                "+m" (*addr), "=a" (result) :
0576                "1" (newval) :
0577                "cc");
0578   return result;
0579 }
0580 
0581 static inline uint
0582 rcr2(void)
0583 {
0584   uint val;
0585   asm volatile("movl %%cr2,%0" : "=r" (val));
0586   return val;
0587 }
0588 
0589 static inline void
0590 lcr3(uint val)
0591 {
0592   asm volatile("movl %0,%%cr3" : : "r" (val));
0593 }
0594 
0595 
0596 
0597 
0598 
0599 
0600 
0601 
0602 struct trapframe {
0603   
0604   uint edi;
0605   uint esi;
0606   uint ebp;
0607   uint oesp;      
0608   uint ebx;
0609   uint edx;
0610   uint ecx;
0611   uint eax;
0612 
0613   
0614   ushort gs;
0615   ushort padding1;
0616   ushort fs;
0617   ushort padding2;
0618   ushort es;
0619   ushort padding3;
0620   ushort ds;
0621   ushort padding4;
0622   uint trapno;
0623 
0624   
0625   uint err;
0626   uint eip;
0627   ushort cs;
0628   ushort padding5;
0629   uint eflags;
0630 
0631   
0632   uint esp;
0633   ushort ss;
0634   ushort padding6;
0635 };
0636 
0637 
0638 
0639 
0640 
0641 
0642 
0643 
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 
0653 
0654 #define SEG_NULLASM                                             \
0655         .word 0, 0;                                             \
0656         .byte 0, 0, 0, 0
0657 
0658 
0659 
0660 #define SEG_ASM(type,base,lim)                                  \
0661         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0662         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0663                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0664 
0665 #define STA_X     0x8       
0666 #define STA_W     0x2       
0667 #define STA_R     0x2       
0668 
0669 
0670 
0671 
0672 
0673 
0674 
0675 
0676 
0677 
0678 
0679 
0680 
0681 
0682 
0683 
0684 
0685 
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define FL_IF           0x00000200      
0705 
0706 
0707 #define CR0_PE          0x00000001      
0708 #define CR0_WP          0x00010000      
0709 #define CR0_PG          0x80000000      
0710 
0711 #define CR4_PSE         0x00000010      
0712 
0713 
0714 #define SEG_KCODE 1  
0715 #define SEG_KDATA 2  
0716 #define SEG_UCODE 3  
0717 #define SEG_UDATA 4  
0718 #define SEG_TSS   5  
0719 
0720 
0721 #define NSEGS     6
0722 
0723 #ifndef __ASSEMBLER__
0724 
0725 struct segdesc {
0726   uint lim_15_0 : 16;  
0727   uint base_15_0 : 16; 
0728   uint base_23_16 : 8; 
0729   uint type : 4;       
0730   uint s : 1;          
0731   uint dpl : 2;        
0732   uint p : 1;          
0733   uint lim_19_16 : 4;  
0734   uint avl : 1;        
0735   uint rsv1 : 1;       
0736   uint db : 1;         
0737   uint g : 1;          
0738   uint base_31_24 : 8; 
0739 };
0740 
0741 
0742 
0743 
0744 
0745 
0746 
0747 
0748 
0749 
0750 
0751 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0752 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0753   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0754   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0755 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0756 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0757   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0758   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0759 #endif
0760 
0761 #define DPL_USER    0x3     
0762 
0763 
0764 #define STA_X       0x8     
0765 #define STA_W       0x2     
0766 #define STA_R       0x2     
0767 
0768 
0769 #define STS_T32A    0x9     
0770 #define STS_IG32    0xE     
0771 #define STS_TG32    0xF     
0772 
0773 
0774 
0775 
0776 
0777 
0778 
0779 
0780 
0781 
0782 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0783 
0784 
0785 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0786 
0787 
0788 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0789 
0790 
0791 #define NPDENTRIES      1024    
0792 #define NPTENTRIES      1024    
0793 #define PGSIZE          4096    
0794 
0795 #define PTXSHIFT        12      
0796 #define PDXSHIFT        22      
0797 
0798 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0799 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0800 
0801 #define PTE_P           0x001   
0802 #define PTE_W           0x002   
0803 #define PTE_U           0x004   
0804 #define PTE_PS          0x080   
0805 
0806 
0807 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0808 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0809 
0810 #ifndef __ASSEMBLER__
0811 typedef uint pte_t;
0812 
0813 
0814 struct taskstate {
0815   uint link;         
0816   uint esp0;         
0817   ushort ss0;        
0818   ushort padding1;
0819   uint *esp1;
0820   ushort ss1;
0821   ushort padding2;
0822   uint *esp2;
0823   ushort ss2;
0824   ushort padding3;
0825   void *cr3;         
0826   uint *eip;         
0827   uint eflags;
0828   uint eax;          
0829   uint ecx;
0830   uint edx;
0831   uint ebx;
0832   uint *esp;
0833   uint *ebp;
0834   uint esi;
0835   uint edi;
0836   ushort es;         
0837   ushort padding4;
0838   ushort cs;
0839   ushort padding5;
0840   ushort ss;
0841   ushort padding6;
0842   ushort ds;
0843   ushort padding7;
0844   ushort fs;
0845   ushort padding8;
0846   ushort gs;
0847   ushort padding9;
0848   ushort ldt;
0849   ushort padding10;
0850   ushort t;          
0851   ushort iomb;       
0852 };
0853 
0854 
0855 struct gatedesc {
0856   uint off_15_0 : 16;   
0857   uint cs : 16;         
0858   uint args : 5;        
0859   uint rsv1 : 3;        
0860   uint type : 4;        
0861   uint s : 1;           
0862   uint dpl : 2;         
0863   uint p : 1;           
0864   uint off_31_16 : 16;  
0865 };
0866 
0867 
0868 
0869 
0870 
0871 
0872 
0873 
0874 
0875 #define SETGATE(gate, istrap, sel, off, d)                \
0876 {                                                         \
0877   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0878   (gate).cs = (sel);                                      \
0879   (gate).args = 0;                                        \
0880   (gate).rsv1 = 0;                                        \
0881   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0882   (gate).s = 0;                                           \
0883   (gate).dpl = (d);                                       \
0884   (gate).p = 1;                                           \
0885   (gate).off_31_16 = (uint)(off) >> 16;                  \
0886 }
0887 
0888 #endif
0889 
0890 
0891 
0892 
0893 
0894 
0895 
0896 
0897 
0898 
0899 
0900 
0901 
0902 #define ELF_MAGIC 0x464C457FU  
0903 
0904 
0905 struct elfhdr {
0906   uint magic;  
0907   uchar elf[12];
0908   ushort type;
0909   ushort machine;
0910   uint version;
0911   uint entry;
0912   uint phoff;
0913   uint shoff;
0914   uint flags;
0915   ushort ehsize;
0916   ushort phentsize;
0917   ushort phnum;
0918   ushort shentsize;
0919   ushort shnum;
0920   ushort shstrndx;
0921 };
0922 
0923 
0924 struct proghdr {
0925   uint type;
0926   uint off;
0927   uint vaddr;
0928   uint paddr;
0929   uint filesz;
0930   uint memsz;
0931   uint flags;
0932   uint align;
0933 };
0934 
0935 
0936 #define ELF_PROG_LOAD           1
0937 
0938 
0939 #define ELF_PROG_FLAG_EXEC      1
0940 #define ELF_PROG_FLAG_WRITE     2
0941 #define ELF_PROG_FLAG_READ      4
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 struct rtcdate {
0951   uint second;
0952   uint minute;
0953   uint hour;
0954   uint day;
0955   uint month;
0956   uint year;
0957 };
0958 
0959 
0960 
0961 
0962 
0963 
0964 
0965 
0966 
0967 
0968 
0969 
0970 
0971 
0972 
0973 
0974 
0975 
0976 
0977 
0978 
0979 
0980 
0981 
0982 
0983 
0984 
0985 
0986 
0987 
0988 
0989 
0990 
0991 
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 
1001 
1002 
1003 
1004 
1005 
1006 
1007 
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 
1023 
1024 
1025 
1026 .p2align 2
1027 .text
1028 .globl multiboot_header
1029 multiboot_header:
1030   
1031   
1032   .long magic
1033   .long flags
1034   .long (-magic-flags)
1035 
1036 
1037 
1038 
1039 .globl _start
1040 _start = V2P_WO(entry)
1041 
1042 
1043 .globl entry
1044 entry:
1045   
1046   movl    %cr4, %eax
1047   orl     $(CR4_PSE), %eax
1048   movl    %eax, %cr4
1049   
1050   movl    $(V2P_WO(entrypgdir)), %eax
1051   movl    %eax, %cr3
1052   
1053   movl    %cr0, %eax
1054   orl     $(CR0_PG|CR0_WP), %eax
1055   movl    %eax, %cr0
1056 
1057   
1058   movl $(stack + KSTACKSIZE), %esp
1059 
1060   
1061   
1062   
1063   
1064   mov $main, %eax
1065   jmp *%eax
1066 
1067 .comm stack, KSTACKSIZE
1068 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 
1077 
1078 
1079 
1080 
1081 
1082 
1083 
1084 
1085 
1086 
1087 
1088 
1089 
1090 
1091 
1092 
1093 
1094 
1095 
1096 
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 .code16
1122 .globl start
1123 start:
1124   cli
1125 
1126   
1127   xorw    %ax,%ax
1128   movw    %ax,%ds
1129   movw    %ax,%es
1130   movw    %ax,%ss
1131 
1132   
1133   
1134   
1135   lgdt    gdtdesc
1136   movl    %cr0, %eax
1137   orl     $CR0_PE, %eax
1138   movl    %eax, %cr0
1139 
1140   
1141   
1142   
1143   ljmpl    $(SEG_KCODE<<3), $(start32)
1144 
1145 
1146 
1147 
1148 
1149 
1150 .code32  
1151 start32:
1152   
1153   movw    $(SEG_KDATA<<3), %ax    
1154   movw    %ax, %ds                
1155   movw    %ax, %es                
1156   movw    %ax, %ss                
1157   movw    $0, %ax                 
1158   movw    %ax, %fs                
1159   movw    %ax, %gs                
1160 
1161   
1162   movl    %cr4, %eax
1163   orl     $(CR4_PSE), %eax
1164   movl    %eax, %cr4
1165   
1166   movl    (start-12), %eax
1167   movl    %eax, %cr3
1168   
1169   movl    %cr0, %eax
1170   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1171   movl    %eax, %cr0
1172 
1173   
1174   movl    (start-4), %esp
1175   
1176   call	 *(start-8)
1177 
1178   movw    $0x8a00, %ax
1179   movw    %ax, %dx
1180   outw    %ax, %dx
1181   movw    $0x8ae0, %ax
1182   outw    %ax, %dx
1183 spin:
1184   jmp     spin
1185 
1186 .p2align 2
1187 gdt:
1188   SEG_NULLASM
1189   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1190   SEG_ASM(STA_W, 0, 0xffffffff)
1191 
1192 
1193 gdtdesc:
1194   .word   (gdtdesc - gdt - 1)
1195   .long   gdt
1196 
1197 
1198 
1199 
1200 #include "types.h"
1201 #include "defs.h"
1202 #include "param.h"
1203 #include "memlayout.h"
1204 #include "mmu.h"
1205 #include "proc.h"
1206 #include "x86.h"
1207 
1208 static void startothers(void);
1209 static void mpmain(void)  __attribute__((noreturn));
1210 extern pde_t *kpgdir;
1211 extern char end[]; 
1212 
1213 
1214 
1215 
1216 int
1217 main(void)
1218 {
1219   kinit1(end, P2V(4*1024*1024)); 
1220   kvmalloc();      
1221   mpinit();        
1222   lapicinit();     
1223   seginit();       
1224   picinit();       
1225   ioapicinit();    
1226   consoleinit();   
1227   uartinit();      
1228   pinit();         
1229   tvinit();        
1230   binit();         
1231   fileinit();      
1232   ideinit();       
1233   startothers();   
1234   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1235   userinit();      
1236   mpmain();        
1237 }
1238 
1239 
1240 static void
1241 mpenter(void)
1242 {
1243   switchkvm();
1244   seginit();
1245   lapicinit();
1246   mpmain();
1247 }
1248 
1249 
1250 
1251 static void
1252 mpmain(void)
1253 {
1254   cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
1255   idtinit();       
1256   xchg(&(mycpu()->started), 1); 
1257   scheduler();     
1258 }
1259 
1260 pde_t entrypgdir[];  
1261 
1262 
1263 static void
1264 startothers(void)
1265 {
1266   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1267   uchar *code;
1268   struct cpu *c;
1269   char *stack;
1270 
1271   
1272   
1273   
1274   code = P2V(0x7000);
1275   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1276 
1277   for(c = cpus; c < cpus+ncpu; c++){
1278     if(c == mycpu())  
1279       continue;
1280 
1281     
1282     
1283     
1284     stack = kalloc();
1285     *(void**)(code-4) = stack + KSTACKSIZE;
1286     *(void(**)(void))(code-8) = mpenter;
1287     *(int**)(code-12) = (void *) V2P(entrypgdir);
1288 
1289     lapicstartap(c->apicid, V2P(code));
1290 
1291     
1292     while(c->started == 0)
1293       ;
1294   }
1295 }
1296 
1297 
1298 
1299 
1300 
1301 
1302 
1303 
1304 
1305 __attribute__((__aligned__(PGSIZE)))
1306 pde_t entrypgdir[NPDENTRIES] = {
1307   
1308   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1309   
1310   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1311 };
1312 
1313 
1314 
1315 
1316 
1317 
1318 
1319 
1320 
1321 
1322 
1323 
1324 
1325 
1326 
1327 
1328 
1329 
1330 
1331 
1332 
1333 
1334 
1335 
1336 
1337 
1338 
1339 
1340 
1341 
1342 
1343 
1344 
1345 
1346 
1347 
1348 
1349 
1350 
1351 
1352 
1353 
1354 
1355 
1356 
1357 
1358 
1359 
1360 
1361 
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 
1403 
1404 
1405 
1406 
1407 
1408 
1409 
1410 
1411 
1412 
1413 
1414 
1415 
1416 
1417 
1418 
1419 
1420 
1421 
1422 
1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431 
1432 
1433 
1434 
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 
1452 
1453 
1454 
1455 
1456 
1457 
1458 
1459 
1460 
1461 
1462 
1463 
1464 
1465 
1466 
1467 
1468 
1469 
1470 
1471 
1472 
1473 
1474 
1475 
1476 
1477 
1478 
1479 
1480 
1481 
1482 
1483 
1484 
1485 
1486 
1487 
1488 
1489 
1490 
1491 
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 struct spinlock {
1502   uint locked;       
1503 
1504   
1505   char *name;        
1506   struct cpu *cpu;   
1507   uint pcs[10];      
1508                      
1509 };
1510 
1511 
1512 
1513 
1514 
1515 
1516 
1517 
1518 
1519 
1520 
1521 
1522 
1523 
1524 
1525 
1526 
1527 
1528 
1529 
1530 
1531 
1532 
1533 
1534 
1535 
1536 
1537 
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 
1551 
1552 #include "types.h"
1553 #include "defs.h"
1554 #include "param.h"
1555 #include "x86.h"
1556 #include "memlayout.h"
1557 #include "mmu.h"
1558 #include "proc.h"
1559 #include "spinlock.h"
1560 
1561 void
1562 initlock(struct spinlock *lk, char *name)
1563 {
1564   lk->name = name;
1565   lk->locked = 0;
1566   lk->cpu = 0;
1567 }
1568 
1569 
1570 
1571 
1572 
1573 void
1574 acquire(struct spinlock *lk)
1575 {
1576   pushcli(); 
1577   if(holding(lk))
1578     panic("acquire");
1579 
1580   
1581   while(xchg(&lk->locked, 1) != 0)
1582     ;
1583 
1584   
1585   
1586   
1587   __sync_synchronize();
1588 
1589   
1590   lk->cpu = mycpu();
1591   getcallerpcs(&lk, lk->pcs);
1592 }
1593 
1594 
1595 
1596 
1597 
1598 
1599 
1600 
1601 void
1602 release(struct spinlock *lk)
1603 {
1604   if(!holding(lk))
1605     panic("release");
1606 
1607   lk->pcs[0] = 0;
1608   lk->cpu = 0;
1609 
1610   
1611   
1612   
1613   
1614   
1615   __sync_synchronize();
1616 
1617   
1618   
1619   
1620   asm volatile("movl $0, %0" : "+m" (lk->locked) : );
1621 
1622   popcli();
1623 }
1624 
1625 
1626 void
1627 getcallerpcs(void *v, uint pcs[])
1628 {
1629   uint *ebp;
1630   int i;
1631 
1632   ebp = (uint*)v - 2;
1633   for(i = 0; i < 10; i++){
1634     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1635       break;
1636     pcs[i] = ebp[1];     
1637     ebp = (uint*)ebp[0]; 
1638   }
1639   for(; i < 10; i++)
1640     pcs[i] = 0;
1641 }
1642 
1643 
1644 
1645 
1646 
1647 
1648 
1649 
1650 
1651 int
1652 holding(struct spinlock *lock)
1653 {
1654   int r;
1655   pushcli();
1656   r = lock->locked && lock->cpu == mycpu();
1657   popcli();
1658   return r;
1659 }
1660 
1661 
1662 
1663 
1664 
1665 
1666 void
1667 pushcli(void)
1668 {
1669   int eflags;
1670 
1671   eflags = readeflags();
1672   cli();
1673   if(mycpu()->ncli == 0)
1674     mycpu()->intena = eflags & FL_IF;
1675   mycpu()->ncli += 1;
1676 }
1677 
1678 void
1679 popcli(void)
1680 {
1681   if(readeflags()&FL_IF)
1682     panic("popcli - interruptible");
1683   if(--mycpu()->ncli < 0)
1684     panic("popcli");
1685   if(mycpu()->ncli == 0 && mycpu()->intena)
1686     sti();
1687 }
1688 
1689 
1690 
1691 
1692 
1693 
1694 
1695 
1696 
1697 
1698 
1699 
1700 #include "param.h"
1701 #include "types.h"
1702 #include "defs.h"
1703 #include "x86.h"
1704 #include "memlayout.h"
1705 #include "mmu.h"
1706 #include "proc.h"
1707 #include "elf.h"
1708 
1709 extern char data[];  
1710 pde_t *kpgdir;  
1711 
1712 
1713 
1714 void
1715 seginit(void)
1716 {
1717   struct cpu *c;
1718 
1719   
1720   
1721   
1722   
1723   c = &cpus[cpuid()];
1724   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1725   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1726   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1727   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1728   lgdt(c->gdt, sizeof(c->gdt));
1729 }
1730 
1731 
1732 
1733 
1734 static pte_t *
1735 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1736 {
1737   pde_t *pde;
1738   pte_t *pgtab;
1739 
1740   pde = &pgdir[PDX(va)];
1741   if(*pde & PTE_P){
1742     pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
1743   } else {
1744     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1745       return 0;
1746     
1747     memset(pgtab, 0, PGSIZE);
1748     
1749     
1750     
1751     *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
1752   }
1753   return &pgtab[PTX(va)];
1754 }
1755 
1756 
1757 
1758 
1759 static int
1760 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1761 {
1762   char *a, *last;
1763   pte_t *pte;
1764 
1765   a = (char*)PGROUNDDOWN((uint)va);
1766   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1767   for(;;){
1768     if((pte = walkpgdir(pgdir, a, 1)) == 0)
1769       return -1;
1770     if(*pte & PTE_P)
1771       panic("remap");
1772     *pte = pa | perm | PTE_P;
1773     if(a == last)
1774       break;
1775     a += PGSIZE;
1776     pa += PGSIZE;
1777   }
1778   return 0;
1779 }
1780 
1781 
1782 
1783 
1784 
1785 
1786 
1787 
1788 
1789 
1790 
1791 
1792 
1793 
1794 
1795 
1796 
1797 
1798 
1799 
1800 
1801 
1802 
1803 
1804 static struct kmap {
1805   void *virt;
1806   uint phys_start;
1807   uint phys_end;
1808   int perm;
1809 } kmap[] = {
1810  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1811  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1812  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1813  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1814 };
1815 
1816 
1817 pde_t*
1818 setupkvm(void)
1819 {
1820   pde_t *pgdir;
1821   struct kmap *k;
1822 
1823   if((pgdir = (pde_t*)kalloc()) == 0)
1824     return 0;
1825   memset(pgdir, 0, PGSIZE);
1826   if (P2V(PHYSTOP) > (void*)DEVSPACE)
1827     panic("PHYSTOP too high");
1828   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1829     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1830                 (uint)k->phys_start, k->perm) < 0) {
1831       freevm(pgdir);
1832       return 0;
1833     }
1834   return pgdir;
1835 }
1836 
1837 
1838 
1839 void
1840 kvmalloc(void)
1841 {
1842   kpgdir = setupkvm();
1843   switchkvm();
1844 }
1845 
1846 
1847 
1848 
1849 
1850 
1851 
1852 void
1853 switchkvm(void)
1854 {
1855   lcr3(V2P(kpgdir));   
1856 }
1857 
1858 
1859 void
1860 switchuvm(struct proc *p)
1861 {
1862   if(p == 0)
1863     panic("switchuvm: no process");
1864   if(p->kstack == 0)
1865     panic("switchuvm: no kstack");
1866   if(p->pgdir == 0)
1867     panic("switchuvm: no pgdir");
1868 
1869   pushcli();
1870   mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
1871                                 sizeof(mycpu()->ts)-1, 0);
1872   mycpu()->gdt[SEG_TSS].s = 0;
1873   mycpu()->ts.ss0 = SEG_KDATA << 3;
1874   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
1875   
1876   
1877   mycpu()->ts.iomb = (ushort) 0xFFFF;
1878   ltr(SEG_TSS << 3);
1879   lcr3(V2P(p->pgdir));  
1880   popcli();
1881 }
1882 
1883 
1884 
1885 void
1886 inituvm(pde_t *pgdir, char *init, uint sz)
1887 {
1888   char *mem;
1889 
1890   if(sz >= PGSIZE)
1891     panic("inituvm: more than a page");
1892   mem = kalloc();
1893   memset(mem, 0, PGSIZE);
1894   mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
1895   memmove(mem, init, sz);
1896 }
1897 
1898 
1899 
1900 
1901 
1902 int
1903 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1904 {
1905   uint i, pa, n;
1906   pte_t *pte;
1907 
1908   if((uint) addr % PGSIZE != 0)
1909     panic("loaduvm: addr must be page aligned");
1910   for(i = 0; i < sz; i += PGSIZE){
1911     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1912       panic("loaduvm: address should exist");
1913     pa = PTE_ADDR(*pte);
1914     if(sz - i < PGSIZE)
1915       n = sz - i;
1916     else
1917       n = PGSIZE;
1918     if(readi(ip, P2V(pa), offset+i, n) != n)
1919       return -1;
1920   }
1921   return 0;
1922 }
1923 
1924 
1925 
1926 int
1927 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1928 {
1929   char *mem;
1930   uint a;
1931 
1932   if(newsz >= KERNBASE)
1933     return 0;
1934   if(newsz < oldsz)
1935     return oldsz;
1936 
1937   a = PGROUNDUP(oldsz);
1938   for(; a < newsz; a += PGSIZE){
1939     mem = kalloc();
1940     if(mem == 0){
1941       cprintf("allocuvm out of memory\n");
1942       deallocuvm(pgdir, newsz, oldsz);
1943       return 0;
1944     }
1945     memset(mem, 0, PGSIZE);
1946     if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
1947       cprintf("allocuvm out of memory (2)\n");
1948       deallocuvm(pgdir, newsz, oldsz);
1949       kfree(mem);
1950       return 0;
1951     }
1952   }
1953   return newsz;
1954 }
1955 
1956 
1957 
1958 
1959 
1960 int
1961 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1962 {
1963   pte_t *pte;
1964   uint a, pa;
1965 
1966   if(newsz >= oldsz)
1967     return oldsz;
1968 
1969   a = PGROUNDUP(newsz);
1970   for(; a  < oldsz; a += PGSIZE){
1971     pte = walkpgdir(pgdir, (char*)a, 0);
1972     if(!pte)
1973       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
1974     else if((*pte & PTE_P) != 0){
1975       pa = PTE_ADDR(*pte);
1976       if(pa == 0)
1977         panic("kfree");
1978       char *v = P2V(pa);
1979       kfree(v);
1980       *pte = 0;
1981     }
1982   }
1983   return newsz;
1984 }
1985 
1986 
1987 
1988 
1989 
1990 
1991 
1992 
1993 
1994 
1995 
1996 
1997 
1998 
1999 
2000 
2001 
2002 void
2003 freevm(pde_t *pgdir)
2004 {
2005   uint i;
2006 
2007   if(pgdir == 0)
2008     panic("freevm: no pgdir");
2009   deallocuvm(pgdir, KERNBASE, 0);
2010   for(i = 0; i < NPDENTRIES; i++){
2011     if(pgdir[i] & PTE_P){
2012       char * v = P2V(PTE_ADDR(pgdir[i]));
2013       kfree(v);
2014     }
2015   }
2016   kfree((char*)pgdir);
2017 }
2018 
2019 
2020 
2021 void
2022 clearpteu(pde_t *pgdir, char *uva)
2023 {
2024   pte_t *pte;
2025 
2026   pte = walkpgdir(pgdir, uva, 0);
2027   if(pte == 0)
2028     panic("clearpteu");
2029   *pte &= ~PTE_U;
2030 }
2031 
2032 
2033 
2034 pde_t*
2035 copyuvm(pde_t *pgdir, uint sz)
2036 {
2037   pde_t *d;
2038   pte_t *pte;
2039   uint pa, i, flags;
2040   char *mem;
2041 
2042   if((d = setupkvm()) == 0)
2043     return 0;
2044   for(i = 0; i < sz; i += PGSIZE){
2045     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
2046       panic("copyuvm: pte should exist");
2047     if(!(*pte & PTE_P))
2048       panic("copyuvm: page not present");
2049     pa = PTE_ADDR(*pte);
2050     flags = PTE_FLAGS(*pte);
2051     if((mem = kalloc()) == 0)
2052       goto bad;
2053     memmove(mem, (char*)P2V(pa), PGSIZE);
2054     if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0) {
2055       kfree(mem);
2056       goto bad;
2057     }
2058   }
2059   return d;
2060 
2061 bad:
2062   freevm(d);
2063   return 0;
2064 }
2065 
2066 
2067 
2068 
2069 
2070 
2071 
2072 
2073 
2074 
2075 
2076 
2077 
2078 
2079 
2080 
2081 
2082 
2083 
2084 
2085 
2086 
2087 
2088 
2089 
2090 
2091 
2092 
2093 
2094 
2095 
2096 
2097 
2098 
2099 
2100 
2101 char*
2102 uva2ka(pde_t *pgdir, char *uva)
2103 {
2104   pte_t *pte;
2105 
2106   pte = walkpgdir(pgdir, uva, 0);
2107   if((*pte & PTE_P) == 0)
2108     return 0;
2109   if((*pte & PTE_U) == 0)
2110     return 0;
2111   return (char*)P2V(PTE_ADDR(*pte));
2112 }
2113 
2114 
2115 
2116 
2117 int
2118 copyout(pde_t *pgdir, uint va, void *p, uint len)
2119 {
2120   char *buf, *pa0;
2121   uint n, va0;
2122 
2123   buf = (char*)p;
2124   while(len > 0){
2125     va0 = (uint)PGROUNDDOWN(va);
2126     pa0 = uva2ka(pgdir, (char*)va0);
2127     if(pa0 == 0)
2128       return -1;
2129     n = PGSIZE - (va - va0);
2130     if(n > len)
2131       n = len;
2132     memmove(pa0 + (va - va0), buf, n);
2133     len -= n;
2134     buf += n;
2135     va = va0 + PGSIZE;
2136   }
2137   return 0;
2138 }
2139 
2140 
2141 
2142 
2143 
2144 
2145 
2146 
2147 
2148 
2149 
2150 
2151 
2152 
2153 
2154 
2155 
2156 
2157 
2158 
2159 
2160 
2161 
2162 
2163 
2164 
2165 
2166 
2167 
2168 
2169 
2170 
2171 
2172 
2173 
2174 
2175 
2176 
2177 
2178 
2179 
2180 
2181 
2182 
2183 
2184 
2185 
2186 
2187 
2188 
2189 
2190 
2191 
2192 
2193 
2194 
2195 
2196 
2197 
2198 
2199 
2200 
2201 
2202 
2203 
2204 
2205 
2206 
2207 
2208 
2209 
2210 
2211 
2212 
2213 
2214 
2215 
2216 
2217 
2218 
2219 
2220 
2221 
2222 
2223 
2224 
2225 
2226 
2227 
2228 
2229 
2230 
2231 
2232 
2233 
2234 
2235 
2236 
2237 
2238 
2239 
2240 
2241 
2242 
2243 
2244 
2245 
2246 
2247 
2248 
2249 
2250 
2251 
2252 
2253 
2254 
2255 
2256 
2257 
2258 
2259 
2260 
2261 
2262 
2263 
2264 
2265 
2266 
2267 
2268 
2269 
2270 
2271 
2272 
2273 
2274 
2275 
2276 
2277 
2278 
2279 
2280 
2281 
2282 
2283 
2284 
2285 
2286 
2287 
2288 
2289 
2290 
2291 
2292 
2293 
2294 
2295 
2296 
2297 
2298 
2299 
2300 
2301 struct cpu {
2302   uchar apicid;                
2303   struct context *scheduler;   
2304   struct taskstate ts;         
2305   struct segdesc gdt[NSEGS];   
2306   volatile uint started;       
2307   int ncli;                    
2308   int intena;                  
2309   struct proc *proc;           
2310 };
2311 
2312 extern struct cpu cpus[NCPU];
2313 extern int ncpu;
2314 
2315 
2316 
2317 
2318 
2319 
2320 
2321 
2322 
2323 
2324 
2325 
2326 struct context {
2327   uint edi;
2328   uint esi;
2329   uint ebx;
2330   uint ebp;
2331   uint eip;
2332 };
2333 
2334 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2335 
2336 
2337 struct proc {
2338   uint sz;                     
2339   pde_t* pgdir;                
2340   char *kstack;                
2341   enum procstate state;        
2342   int pid;                     
2343   struct proc *parent;         
2344   struct trapframe *tf;        
2345   struct context *context;     
2346   void *chan;                  
2347   int killed;                  
2348   struct file *ofile[NOFILE];  
2349   struct inode *cwd;           
2350   char name[16];               
2351 };
2352 
2353 
2354 
2355 
2356 
2357 
2358 
2359 
2360 
2361 
2362 
2363 
2364 
2365 
2366 
2367 
2368 
2369 
2370 
2371 
2372 
2373 
2374 
2375 
2376 
2377 
2378 
2379 
2380 
2381 
2382 
2383 
2384 
2385 
2386 
2387 
2388 
2389 
2390 
2391 
2392 
2393 
2394 
2395 
2396 
2397 
2398 
2399 
2400 #include "types.h"
2401 #include "defs.h"
2402 #include "param.h"
2403 #include "memlayout.h"
2404 #include "mmu.h"
2405 #include "x86.h"
2406 #include "proc.h"
2407 #include "spinlock.h"
2408 
2409 struct {
2410   struct spinlock lock;
2411   struct proc proc[NPROC];
2412 } ptable;
2413 
2414 static struct proc *initproc;
2415 
2416 int nextpid = 1;
2417 extern void forkret(void);
2418 extern void trapret(void);
2419 
2420 static void wakeup1(void *chan);
2421 
2422 void
2423 pinit(void)
2424 {
2425   initlock(&ptable.lock, "ptable");
2426 }
2427 
2428 
2429 int
2430 cpuid() {
2431   return mycpu()-cpus;
2432 }
2433 
2434 
2435 
2436 struct cpu*
2437 mycpu(void)
2438 {
2439   int apicid, i;
2440 
2441   if(readeflags()&FL_IF)
2442     panic("mycpu called with interrupts enabled\n");
2443 
2444   apicid = lapicid();
2445   
2446   
2447   for (i = 0; i < ncpu; ++i) {
2448     if (cpus[i].apicid == apicid)
2449       return &cpus[i];
2450   }
2451   panic("unknown apicid\n");
2452 }
2453 
2454 
2455 
2456 struct proc*
2457 myproc(void) {
2458   struct cpu *c;
2459   struct proc *p;
2460   pushcli();
2461   c = mycpu();
2462   p = c->proc;
2463   popcli();
2464   return p;
2465 }
2466 
2467 
2468 
2469 
2470 
2471 
2472 static struct proc*
2473 allocproc(void)
2474 {
2475   struct proc *p;
2476   char *sp;
2477 
2478   acquire(&ptable.lock);
2479 
2480   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2481     if(p->state == UNUSED)
2482       goto found;
2483 
2484   release(&ptable.lock);
2485   return 0;
2486 
2487 found:
2488   p->state = EMBRYO;
2489   p->pid = nextpid++;
2490 
2491   release(&ptable.lock);
2492 
2493   
2494   if((p->kstack = kalloc()) == 0){
2495     p->state = UNUSED;
2496     return 0;
2497   }
2498   sp = p->kstack + KSTACKSIZE;
2499 
2500   
2501   sp -= sizeof *p->tf;
2502   p->tf = (struct trapframe*)sp;
2503 
2504   
2505   
2506   sp -= 4;
2507   *(uint*)sp = (uint)trapret;
2508 
2509   sp -= sizeof *p->context;
2510   p->context = (struct context*)sp;
2511   memset(p->context, 0, sizeof *p->context);
2512   p->context->eip = (uint)forkret;
2513 
2514   return p;
2515 }
2516 
2517 
2518 
2519 void
2520 userinit(void)
2521 {
2522   struct proc *p;
2523   extern char _binary_initcode_start[], _binary_initcode_size[];
2524 
2525   p = allocproc();
2526 
2527   initproc = p;
2528   if((p->pgdir = setupkvm()) == 0)
2529     panic("userinit: out of memory?");
2530   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2531   p->sz = PGSIZE;
2532   memset(p->tf, 0, sizeof(*p->tf));
2533   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2534   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2535   p->tf->es = p->tf->ds;
2536   p->tf->ss = p->tf->ds;
2537   p->tf->eflags = FL_IF;
2538   p->tf->esp = PGSIZE;
2539   p->tf->eip = 0;  
2540 
2541   safestrcpy(p->name, "initcode", sizeof(p->name));
2542   p->cwd = namei("/");
2543 
2544   
2545   
2546   
2547   
2548   acquire(&ptable.lock);
2549 
2550   p->state = RUNNABLE;
2551 
2552   release(&ptable.lock);
2553 }
2554 
2555 
2556 
2557 int
2558 growproc(int n)
2559 {
2560   uint sz;
2561   struct proc *curproc = myproc();
2562 
2563   sz = curproc->sz;
2564   if(n > 0){
2565     if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
2566       return -1;
2567   } else if(n < 0){
2568     if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
2569       return -1;
2570   }
2571   curproc->sz = sz;
2572   switchuvm(curproc);
2573   return 0;
2574 }
2575 
2576 
2577 
2578 
2579 int
2580 fork(void)
2581 {
2582   int i, pid;
2583   struct proc *np;
2584   struct proc *curproc = myproc();
2585 
2586   
2587   if((np = allocproc()) == 0){
2588     return -1;
2589   }
2590 
2591   
2592   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
2593     kfree(np->kstack);
2594     np->kstack = 0;
2595     np->state = UNUSED;
2596     return -1;
2597   }
2598   np->sz = curproc->sz;
2599   np->parent = curproc;
2600   *np->tf = *curproc->tf;
2601 
2602   
2603   np->tf->eax = 0;
2604 
2605   for(i = 0; i < NOFILE; i++)
2606     if(curproc->ofile[i])
2607       np->ofile[i] = filedup(curproc->ofile[i]);
2608   np->cwd = idup(curproc->cwd);
2609 
2610   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
2611 
2612   pid = np->pid;
2613 
2614   acquire(&ptable.lock);
2615 
2616   np->state = RUNNABLE;
2617 
2618   release(&ptable.lock);
2619 
2620   return pid;
2621 }
2622 
2623 
2624 
2625 
2626 void
2627 exit(void)
2628 {
2629   struct proc *curproc = myproc();
2630   struct proc *p;
2631   int fd;
2632 
2633   if(curproc == initproc)
2634     panic("init exiting");
2635 
2636   
2637   for(fd = 0; fd < NOFILE; fd++){
2638     if(curproc->ofile[fd]){
2639       fileclose(curproc->ofile[fd]);
2640       curproc->ofile[fd] = 0;
2641     }
2642   }
2643 
2644   begin_op();
2645   iput(curproc->cwd);
2646   end_op();
2647   curproc->cwd = 0;
2648 
2649   acquire(&ptable.lock);
2650   
2651   wakeup1(curproc->parent);
2652 
2653   
2654   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2655     if(p->parent == curproc){
2656       p->parent = initproc;
2657       if(p->state == ZOMBIE)
2658         wakeup1(initproc);
2659     }
2660   }
2661 
2662   
2663   curproc->state = ZOMBIE;
2664   sched();
2665   panic("zombie exit");
2666 }
2667 
2668 
2669 
2670 int
2671 wait(void)
2672 {
2673   struct proc *p;
2674   int havekids, pid;
2675   struct proc *curproc = myproc();
2676 
2677   acquire(&ptable.lock);
2678   for(;;){
2679     
2680     havekids = 0;
2681     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2682       if(p->parent != curproc)
2683         continue;
2684       havekids = 1;
2685       if(p->state == ZOMBIE){
2686         
2687         pid = p->pid;
2688         kfree(p->kstack);
2689         p->kstack = 0;
2690         freevm(p->pgdir);
2691         p->pid = 0;
2692         p->parent = 0;
2693         p->name[0] = 0;
2694         p->killed = 0;
2695         p->state = UNUSED;
2696         release(&ptable.lock);
2697         return pid;
2698       }
2699     }
2700     
2701     if(!havekids || curproc->killed){
2702       release(&ptable.lock);
2703       return -1;
2704     }
2705 
2706     
2707     sleep(curproc, &ptable.lock);  
2708   }
2709 }
2710 
2711 
2712 
2713 
2714 
2715 
2716 
2717 
2718 
2719 
2720 
2721 
2722 
2723 
2724 
2725 
2726 
2727 
2728 
2729 
2730 
2731 
2732 
2733 
2734 
2735 
2736 
2737 
2738 
2739 
2740 
2741 
2742 
2743 
2744 
2745 
2746 
2747 
2748 
2749 
2750 
2751 
2752 
2753 
2754 
2755 
2756 
2757 void
2758 scheduler(void)
2759 {
2760   struct proc *p;
2761   struct cpu *c = mycpu();
2762   c->proc = 0;
2763 
2764   for(;;){
2765     
2766     sti();
2767 
2768     
2769     acquire(&ptable.lock);
2770     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2771       if(p->state != RUNNABLE)
2772         continue;
2773 
2774       
2775       
2776       
2777       c->proc = p;
2778       switchuvm(p);
2779       p->state = RUNNING;
2780 
2781       swtch(&(c->scheduler), p->context);
2782       switchkvm();
2783 
2784       
2785       
2786       c->proc = 0;
2787     }
2788     release(&ptable.lock);
2789 
2790   }
2791 }
2792 
2793 
2794 
2795 
2796 
2797 
2798 
2799 
2800 
2801 
2802 
2803 
2804 
2805 
2806 
2807 void
2808 sched(void)
2809 {
2810   int intena;
2811   struct proc *p = myproc();
2812 
2813   if(!holding(&ptable.lock))
2814     panic("sched ptable.lock");
2815   if(mycpu()->ncli != 1)
2816     panic("sched locks");
2817   if(p->state == RUNNING)
2818     panic("sched running");
2819   if(readeflags()&FL_IF)
2820     panic("sched interruptible");
2821   intena = mycpu()->intena;
2822   swtch(&p->context, mycpu()->scheduler);
2823   mycpu()->intena = intena;
2824 }
2825 
2826 
2827 void
2828 yield(void)
2829 {
2830   acquire(&ptable.lock);  
2831   myproc()->state = RUNNABLE;
2832   sched();
2833   release(&ptable.lock);
2834 }
2835 
2836 
2837 
2838 
2839 
2840 
2841 
2842 
2843 
2844 
2845 
2846 
2847 
2848 
2849 
2850 
2851 
2852 void
2853 forkret(void)
2854 {
2855   static int first = 1;
2856   
2857   release(&ptable.lock);
2858 
2859   if (first) {
2860     
2861     
2862     
2863     first = 0;
2864     iinit(ROOTDEV);
2865     initlog(ROOTDEV);
2866   }
2867 
2868   
2869 }
2870 
2871 
2872 
2873 void
2874 sleep(void *chan, struct spinlock *lk)
2875 {
2876   struct proc *p = myproc();
2877 
2878   if(p == 0)
2879     panic("sleep");
2880 
2881   if(lk == 0)
2882     panic("sleep without lk");
2883 
2884   
2885   
2886   
2887   
2888   
2889   
2890   if(lk != &ptable.lock){  
2891     acquire(&ptable.lock);  
2892     release(lk);
2893   }
2894   
2895   p->chan = chan;
2896   p->state = SLEEPING;
2897 
2898   sched();
2899 
2900   
2901   p->chan = 0;
2902 
2903   
2904   if(lk != &ptable.lock){  
2905     release(&ptable.lock);
2906     acquire(lk);
2907   }
2908 }
2909 
2910 
2911 
2912 
2913 
2914 
2915 
2916 
2917 
2918 
2919 
2920 
2921 
2922 
2923 
2924 
2925 
2926 
2927 
2928 
2929 
2930 
2931 
2932 
2933 
2934 
2935 
2936 
2937 
2938 
2939 
2940 
2941 
2942 
2943 
2944 
2945 
2946 
2947 
2948 
2949 
2950 
2951 
2952 static void
2953 wakeup1(void *chan)
2954 {
2955   struct proc *p;
2956 
2957   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2958     if(p->state == SLEEPING && p->chan == chan)
2959       p->state = RUNNABLE;
2960 }
2961 
2962 
2963 void
2964 wakeup(void *chan)
2965 {
2966   acquire(&ptable.lock);
2967   wakeup1(chan);
2968   release(&ptable.lock);
2969 }
2970 
2971 
2972 
2973 
2974 int
2975 kill(int pid)
2976 {
2977   struct proc *p;
2978 
2979   acquire(&ptable.lock);
2980   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2981     if(p->pid == pid){
2982       p->killed = 1;
2983       
2984       if(p->state == SLEEPING)
2985         p->state = RUNNABLE;
2986       release(&ptable.lock);
2987       return 0;
2988     }
2989   }
2990   release(&ptable.lock);
2991   return -1;
2992 }
2993 
2994 
2995 
2996 
2997 
2998 
2999 
3000 
3001 
3002 
3003 void
3004 procdump(void)
3005 {
3006   static char *states[] = {
3007   [UNUSED]    "unused",
3008   [EMBRYO]    "embryo",
3009   [SLEEPING]  "sleep ",
3010   [RUNNABLE]  "runble",
3011   [RUNNING]   "run   ",
3012   [ZOMBIE]    "zombie"
3013   };
3014   int i;
3015   struct proc *p;
3016   char *state;
3017   uint pc[10];
3018 
3019   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3020     if(p->state == UNUSED)
3021       continue;
3022     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
3023       state = states[p->state];
3024     else
3025       state = "???";
3026     cprintf("%d %s %s", p->pid, state, p->name);
3027     if(p->state == SLEEPING){
3028       getcallerpcs((uint*)p->context->ebp+2, pc);
3029       for(i=0; i<10 && pc[i] != 0; i++)
3030         cprintf(" %p", pc[i]);
3031     }
3032     cprintf("\n");
3033   }
3034 }
3035 
3036 
3037 
3038 
3039 
3040 
3041 
3042 
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 
3051 
3052 
3053 
3054 
3055 
3056 
3057 
3058 .globl swtch
3059 swtch:
3060   movl 4(%esp), %eax
3061   movl 8(%esp), %edx
3062 
3063   
3064   pushl %ebp
3065   pushl %ebx
3066   pushl %esi
3067   pushl %edi
3068 
3069   
3070   movl %esp, (%eax)
3071   movl %edx, %esp
3072 
3073   
3074   popl %edi
3075   popl %esi
3076   popl %ebx
3077   popl %ebp
3078   ret
3079 
3080 
3081 
3082 
3083 
3084 
3085 
3086 
3087 
3088 
3089 
3090 
3091 
3092 
3093 
3094 
3095 
3096 
3097 
3098 
3099 
3100 
3101 
3102 
3103 
3104 #include "types.h"
3105 #include "defs.h"
3106 #include "param.h"
3107 #include "memlayout.h"
3108 #include "mmu.h"
3109 #include "spinlock.h"
3110 
3111 void freerange(void *vstart, void *vend);
3112 extern char end[]; 
3113                    
3114 
3115 struct run {
3116   struct run *next;
3117 };
3118 
3119 struct {
3120   struct spinlock lock;
3121   int use_lock;
3122   struct run *freelist;
3123 } kmem;
3124 
3125 
3126 
3127 
3128 
3129 
3130 void
3131 kinit1(void *vstart, void *vend)
3132 {
3133   initlock(&kmem.lock, "kmem");
3134   kmem.use_lock = 0;
3135   freerange(vstart, vend);
3136 }
3137 
3138 void
3139 kinit2(void *vstart, void *vend)
3140 {
3141   freerange(vstart, vend);
3142   kmem.use_lock = 1;
3143 }
3144 
3145 
3146 
3147 
3148 
3149 
3150 void
3151 freerange(void *vstart, void *vend)
3152 {
3153   char *p;
3154   p = (char*)PGROUNDUP((uint)vstart);
3155   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
3156     kfree(p);
3157 }
3158 
3159 
3160 
3161 
3162 
3163 void
3164 kfree(char *v)
3165 {
3166   struct run *r;
3167 
3168   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
3169     panic("kfree");
3170 
3171   
3172   memset(v, 1, PGSIZE);
3173 
3174   if(kmem.use_lock)
3175     acquire(&kmem.lock);
3176   r = (struct run*)v;
3177   r->next = kmem.freelist;
3178   kmem.freelist = r;
3179   if(kmem.use_lock)
3180     release(&kmem.lock);
3181 }
3182 
3183 
3184 
3185 
3186 char*
3187 kalloc(void)
3188 {
3189   struct run *r;
3190 
3191   if(kmem.use_lock)
3192     acquire(&kmem.lock);
3193   r = kmem.freelist;
3194   if(r)
3195     kmem.freelist = r->next;
3196   if(kmem.use_lock)
3197     release(&kmem.lock);
3198   return (char*)r;
3199 }
3200 
3201 
3202 
3203 #define T_DIVIDE         0      
3204 #define T_DEBUG          1      
3205 #define T_NMI            2      
3206 #define T_BRKPT          3      
3207 #define T_OFLOW          4      
3208 #define T_BOUND          5      
3209 #define T_ILLOP          6      
3210 #define T_DEVICE         7      
3211 #define T_DBLFLT         8      
3212 
3213 #define T_TSS           10      
3214 #define T_SEGNP         11      
3215 #define T_STACK         12      
3216 #define T_GPFLT         13      
3217 #define T_PGFLT         14      
3218 
3219 #define T_FPERR         16      
3220 #define T_ALIGN         17      
3221 #define T_MCHK          18      
3222 #define T_SIMDERR       19      
3223 
3224 
3225 
3226 #define T_SYSCALL       64      
3227 #define T_DEFAULT      500      
3228 
3229 #define T_IRQ0          32      
3230 
3231 #define IRQ_TIMER        0
3232 #define IRQ_KBD          1
3233 #define IRQ_COM1         4
3234 #define IRQ_IDE         14
3235 #define IRQ_ERROR       19
3236 #define IRQ_SPURIOUS    31
3237 
3238 
3239 
3240 
3241 
3242 
3243 
3244 
3245 
3246 
3247 
3248 
3249 
3250 #!/usr/bin/perl -w
3251 
3252 # Generate vectors.S, the trap/interrupt entry points.
3253 # There has to be one entry point per interrupt number
3254 # since otherwise there's no way for trap() to discover
3255 # the interrupt number.
3256 
3257 print "# generated by vectors.pl - do not edit\n";
3258 print "# handlers\n";
3259 print ".globl alltraps\n";
3260 for(my $i = 0; $i < 256; $i++){
3261     print ".globl vector$i\n";
3262     print "vector$i:\n";
3263     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
3264         print "  pushl \$0\n";
3265     }
3266     print "  pushl \$$i\n";
3267     print "  jmp alltraps\n";
3268 }
3269 
3270 print "\n# vector table\n";
3271 print ".data\n";
3272 print ".globl vectors\n";
3273 print "vectors:\n";
3274 for(my $i = 0; $i < 256; $i++){
3275     print "  .long vector$i\n";
3276 }
3277 
3278 # sample output:
3279 #   # handlers
3280 #   .globl alltraps
3281 #   .globl vector0
3282 #   vector0:
3283 #     pushl $0
3284 #     pushl $0
3285 #     jmp alltraps
3286 #   ...
3287 #
3288 #   # vector table
3289 #   .data
3290 #   .globl vectors
3291 #   vectors:
3292 #     .long vector0
3293 #     .long vector1
3294 #     .long vector2
3295 #   ...
3296 
3297 
3298 
3299 
3300 
3301 
3302   
3303 .globl alltraps
3304 alltraps:
3305   
3306   pushl %ds
3307   pushl %es
3308   pushl %fs
3309   pushl %gs
3310   pushal
3311 
3312   
3313   movw $(SEG_KDATA<<3), %ax
3314   movw %ax, %ds
3315   movw %ax, %es
3316 
3317   
3318   pushl %esp
3319   call trap
3320   addl $4, %esp
3321 
3322   
3323 .globl trapret
3324 trapret:
3325   popal
3326   popl %gs
3327   popl %fs
3328   popl %es
3329   popl %ds
3330   addl $0x8, %esp  
3331   iret
3332 
3333 
3334 
3335 
3336 
3337 
3338 
3339 
3340 
3341 
3342 
3343 
3344 
3345 
3346 
3347 
3348 
3349 
3350 #include "types.h"
3351 #include "defs.h"
3352 #include "param.h"
3353 #include "memlayout.h"
3354 #include "mmu.h"
3355 #include "proc.h"
3356 #include "x86.h"
3357 #include "traps.h"
3358 #include "spinlock.h"
3359 
3360 
3361 struct gatedesc idt[256];
3362 extern uint vectors[];  
3363 struct spinlock tickslock;
3364 uint ticks;
3365 
3366 void
3367 tvinit(void)
3368 {
3369   int i;
3370 
3371   for(i = 0; i < 256; i++)
3372     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
3373   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
3374 
3375   initlock(&tickslock, "time");
3376 }
3377 
3378 void
3379 idtinit(void)
3380 {
3381   lidt(idt, sizeof(idt));
3382 }
3383 
3384 
3385 
3386 
3387 
3388 
3389 
3390 
3391 
3392 
3393 
3394 
3395 
3396 
3397 
3398 
3399 
3400 void
3401 trap(struct trapframe *tf)
3402 {
3403   if(tf->trapno == T_SYSCALL){
3404     if(myproc()->killed)
3405       exit();
3406     myproc()->tf = tf;
3407     syscall();
3408     if(myproc()->killed)
3409       exit();
3410     return;
3411   }
3412 
3413   switch(tf->trapno){
3414   case T_IRQ0 + IRQ_TIMER:
3415     if(cpuid() == 0){
3416       acquire(&tickslock);
3417       ticks++;
3418       wakeup(&ticks);
3419       release(&tickslock);
3420     }
3421     lapiceoi();
3422     break;
3423   case T_IRQ0 + IRQ_IDE:
3424     ideintr();
3425     lapiceoi();
3426     break;
3427   case T_IRQ0 + IRQ_IDE+1:
3428     
3429     break;
3430   case T_IRQ0 + IRQ_KBD:
3431     kbdintr();
3432     lapiceoi();
3433     break;
3434   case T_IRQ0 + IRQ_COM1:
3435     uartintr();
3436     lapiceoi();
3437     break;
3438   case T_IRQ0 + 7:
3439   case T_IRQ0 + IRQ_SPURIOUS:
3440     cprintf("cpu%d: spurious interrupt at %x:%x\n",
3441             cpuid(), tf->cs, tf->eip);
3442     lapiceoi();
3443     break;
3444 
3445 
3446 
3447 
3448 
3449 
3450   default:
3451     if(myproc() == 0 || (tf->cs&3) == 0){
3452       
3453       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
3454               tf->trapno, cpuid(), tf->eip, rcr2());
3455       panic("trap");
3456     }
3457     
3458     cprintf("pid %d %s: trap %d err %d on cpu %d "
3459             "eip 0x%x addr 0x%x--kill proc\n",
3460             myproc()->pid, myproc()->name, tf->trapno,
3461             tf->err, cpuid(), tf->eip, rcr2());
3462     myproc()->killed = 1;
3463   }
3464 
3465   
3466   
3467   
3468   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3469     exit();
3470 
3471   
3472   
3473   if(myproc() && myproc()->state == RUNNING &&
3474      tf->trapno == T_IRQ0+IRQ_TIMER)
3475     yield();
3476 
3477   
3478   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3479     exit();
3480 }
3481 
3482 
3483 
3484 
3485 
3486 
3487 
3488 
3489 
3490 
3491 
3492 
3493 
3494 
3495 
3496 
3497 
3498 
3499 
3500 
3501 #define SYS_fork    1
3502 #define SYS_exit    2
3503 #define SYS_wait    3
3504 #define SYS_pipe    4
3505 #define SYS_read    5
3506 #define SYS_kill    6
3507 #define SYS_exec    7
3508 #define SYS_fstat   8
3509 #define SYS_chdir   9
3510 #define SYS_dup    10
3511 #define SYS_getpid 11
3512 #define SYS_sbrk   12
3513 #define SYS_sleep  13
3514 #define SYS_uptime 14
3515 #define SYS_open   15
3516 #define SYS_write  16
3517 #define SYS_mknod  17
3518 #define SYS_unlink 18
3519 #define SYS_link   19
3520 #define SYS_mkdir  20
3521 #define SYS_close  21
3522 #define SYS_head   22
3523 #define SYS_uniq   23
3524 
3525 
3526 
3527 
3528 
3529 
3530 
3531 
3532 
3533 
3534 
3535 
3536 
3537 
3538 
3539 
3540 
3541 
3542 
3543 
3544 
3545 
3546 
3547 
3548 
3549 
3550 #include "types.h"
3551 #include "defs.h"
3552 #include "param.h"
3553 #include "memlayout.h"
3554 #include "mmu.h"
3555 #include "proc.h"
3556 #include "x86.h"
3557 #include "syscall.h"
3558 
3559 
3560 
3561 
3562 
3563 
3564 
3565 
3566 int
3567 fetchint(uint addr, int *ip)
3568 {
3569   struct proc *curproc = myproc();
3570 
3571   if(addr >= curproc->sz || addr+4 > curproc->sz)
3572     return -1;
3573   *ip = *(int*)(addr);
3574   return 0;
3575 }
3576 
3577 
3578 
3579 
3580 int
3581 fetchstr(uint addr, char **pp)
3582 {
3583   char *s, *ep;
3584   struct proc *curproc = myproc();
3585 
3586   if(addr >= curproc->sz)
3587     return -1;
3588   *pp = (char*)addr;
3589   ep = (char*)curproc->sz;
3590   for(s = *pp; s < ep; s++){
3591     if(*s == 0)
3592       return s - *pp;
3593   }
3594   return -1;
3595 }
3596 
3597 
3598 
3599 
3600 
3601 int
3602 argint(int n, int *ip)
3603 {
3604   return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
3605 }
3606 
3607 
3608 
3609 
3610 int
3611 argptr(int n, char **pp, int size)
3612 {
3613   int i;
3614   struct proc *curproc = myproc();
3615 
3616   if(argint(n, &i) < 0)
3617     return -1;
3618   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
3619     return -1;
3620   *pp = (char*)i;
3621   return 0;
3622 }
3623 
3624 
3625 
3626 
3627 
3628 int
3629 argstr(int n, char **pp)
3630 {
3631   int addr;
3632   if(argint(n, &addr) < 0)
3633     return -1;
3634   return fetchstr(addr, pp);
3635 }
3636 
3637 
3638 
3639 
3640 
3641 
3642 
3643 
3644 
3645 
3646 
3647 
3648 
3649 
3650 extern int sys_chdir(void);
3651 extern int sys_close(void);
3652 extern int sys_dup(void);
3653 extern int sys_exec(void);
3654 extern int sys_exit(void);
3655 extern int sys_fork(void);
3656 extern int sys_fstat(void);
3657 extern int sys_getpid(void);
3658 extern int sys_kill(void);
3659 extern int sys_link(void);
3660 extern int sys_mkdir(void);
3661 extern int sys_mknod(void);
3662 extern int sys_open(void);
3663 extern int sys_pipe(void);
3664 extern int sys_read(void);
3665 extern int sys_sbrk(void);
3666 extern int sys_sleep(void);
3667 extern int sys_unlink(void);
3668 extern int sys_wait(void);
3669 extern int sys_write(void);
3670 extern int sys_uptime(void);
3671 extern int sys_head(void);
3672 extern int sys_uniq(void);
3673 
3674 static int (*syscalls[])(void) = {
3675 [SYS_fork]    sys_fork,
3676 [SYS_exit]    sys_exit,
3677 [SYS_wait]    sys_wait,
3678 [SYS_pipe]    sys_pipe,
3679 [SYS_read]    sys_read,
3680 [SYS_kill]    sys_kill,
3681 [SYS_exec]    sys_exec,
3682 [SYS_fstat]   sys_fstat,
3683 [SYS_chdir]   sys_chdir,
3684 [SYS_dup]     sys_dup,
3685 [SYS_getpid]  sys_getpid,
3686 [SYS_sbrk]    sys_sbrk,
3687 [SYS_sleep]   sys_sleep,
3688 [SYS_uptime]  sys_uptime,
3689 [SYS_open]    sys_open,
3690 [SYS_write]   sys_write,
3691 [SYS_mknod]   sys_mknod,
3692 [SYS_unlink]  sys_unlink,
3693 [SYS_link]    sys_link,
3694 [SYS_mkdir]   sys_mkdir,
3695 [SYS_close]   sys_close,
3696 [SYS_head]    sys_head,
3697 [SYS_uniq]    sys_uniq,
3698 };
3699 
3700 void
3701 syscall(void)
3702 {
3703   int num;
3704   struct proc *curproc = myproc();
3705 
3706   num = curproc->tf->eax;
3707   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
3708     curproc->tf->eax = syscalls[num]();
3709   } else {
3710     cprintf("%d %s: unknown sys call %d\n",
3711             curproc->pid, curproc->name, num);
3712     curproc->tf->eax = -1;
3713   }
3714 }
3715 
3716 
3717 
3718 
3719 
3720 
3721 
3722 
3723 
3724 
3725 
3726 
3727 
3728 
3729 
3730 
3731 
3732 
3733 
3734 
3735 
3736 
3737 
3738 
3739 
3740 
3741 
3742 
3743 
3744 
3745 
3746 
3747 
3748 
3749 
3750 #include "types.h"
3751 #include "x86.h"
3752 #include "defs.h"
3753 #include "date.h"
3754 #include "param.h"
3755 #include "memlayout.h"
3756 #include "mmu.h"
3757 #include "proc.h"
3758 
3759 int
3760 sys_fork(void)
3761 {
3762   return fork();
3763 }
3764 
3765 int
3766 sys_exit(void)
3767 {
3768   exit();
3769   return 0;  
3770 }
3771 
3772 int
3773 sys_wait(void)
3774 {
3775   return wait();
3776 }
3777 
3778 int
3779 sys_kill(void)
3780 {
3781   int pid;
3782 
3783   if(argint(0, &pid) < 0)
3784     return -1;
3785   return kill(pid);
3786 }
3787 
3788 int
3789 sys_getpid(void)
3790 {
3791   return myproc()->pid;
3792 }
3793 
3794 
3795 
3796 
3797 
3798 
3799 
3800 int
3801 sys_sbrk(void)
3802 {
3803   int addr;
3804   int n;
3805 
3806   if(argint(0, &n) < 0)
3807     return -1;
3808   addr = myproc()->sz;
3809   if(growproc(n) < 0)
3810     return -1;
3811   return addr;
3812 }
3813 
3814 int
3815 sys_sleep(void)
3816 {
3817   int n;
3818   uint ticks0;
3819 
3820   if(argint(0, &n) < 0)
3821     return -1;
3822   acquire(&tickslock);
3823   ticks0 = ticks;
3824   while(ticks - ticks0 < n){
3825     if(myproc()->killed){
3826       release(&tickslock);
3827       return -1;
3828     }
3829     sleep(&ticks, &tickslock);
3830   }
3831   release(&tickslock);
3832   return 0;
3833 }
3834 
3835 
3836 
3837 int
3838 sys_uptime(void)
3839 {
3840   uint xticks;
3841 
3842   acquire(&tickslock);
3843   xticks = ticks;
3844   release(&tickslock);
3845   return xticks;
3846 }
3847 
3848 
3849 
3850 int
3851 sys_head(char **lines, int* line_length){
3852 
3853   return 0;
3854 }
3855 
3856 int
3857 sys_uniq(void){
3858   char * string;
3859   argstr(1, &string);
3860   cprintf("Arg: here, %s", string);
3861   return 0;
3862 }
3863 
3864 
3865 
3866 
3867 
3868 
3869 
3870 
3871 
3872 
3873 
3874 
3875 
3876 
3877 
3878 
3879 
3880 
3881 
3882 
3883 
3884 
3885 
3886 
3887 
3888 
3889 
3890 
3891 
3892 
3893 
3894 
3895 
3896 
3897 
3898 
3899 
3900 struct buf {
3901   int flags;
3902   uint dev;
3903   uint blockno;
3904   struct sleeplock lock;
3905   uint refcnt;
3906   struct buf *prev; 
3907   struct buf *next;
3908   struct buf *qnext; 
3909   uchar data[BSIZE];
3910 };
3911 #define B_VALID 0x2  
3912 #define B_DIRTY 0x4  
3913 
3914 
3915 
3916 
3917 
3918 
3919 
3920 
3921 
3922 
3923 
3924 
3925 
3926 
3927 
3928 
3929 
3930 
3931 
3932 
3933 
3934 
3935 
3936 
3937 
3938 
3939 
3940 
3941 
3942 
3943 
3944 
3945 
3946 
3947 
3948 
3949 
3950 
3951 struct sleeplock {
3952   uint locked;       
3953   struct spinlock lk; 
3954 
3955   
3956   char *name;        
3957   int pid;           
3958 };
3959 
3960 
3961 
3962 
3963 
3964 
3965 
3966 
3967 
3968 
3969 
3970 
3971 
3972 
3973 
3974 
3975 
3976 
3977 
3978 
3979 
3980 
3981 
3982 
3983 
3984 
3985 
3986 
3987 
3988 
3989 
3990 
3991 
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 #define O_RDONLY  0x000
4001 #define O_WRONLY  0x001
4002 #define O_RDWR    0x002
4003 #define O_CREATE  0x200
4004 
4005 
4006 
4007 
4008 
4009 
4010 
4011 
4012 
4013 
4014 
4015 
4016 
4017 
4018 
4019 
4020 
4021 
4022 
4023 
4024 
4025 
4026 
4027 
4028 
4029 
4030 
4031 
4032 
4033 
4034 
4035 
4036 
4037 
4038 
4039 
4040 
4041 
4042 
4043 
4044 
4045 
4046 
4047 
4048 
4049 
4050 #define T_DIR  1   
4051 #define T_FILE 2   
4052 #define T_DEV  3   
4053 
4054 struct stat {
4055   short type;  
4056   int dev;     
4057   uint ino;    
4058   short nlink; 
4059   uint size;   
4060 };
4061 
4062 
4063 
4064 
4065 
4066 
4067 
4068 
4069 
4070 
4071 
4072 
4073 
4074 
4075 
4076 
4077 
4078 
4079 
4080 
4081 
4082 
4083 
4084 
4085 
4086 
4087 
4088 
4089 
4090 
4091 
4092 
4093 
4094 
4095 
4096 
4097 
4098 
4099 
4100 
4101 
4102 
4103 
4104 #define ROOTINO 1  
4105 #define BSIZE 512  
4106 
4107 
4108 
4109 
4110 
4111 
4112 
4113 struct superblock {
4114   uint size;         
4115   uint nblocks;      
4116   uint ninodes;      
4117   uint nlog;         
4118   uint logstart;     
4119   uint inodestart;   
4120   uint bmapstart;    
4121 };
4122 
4123 #define NDIRECT 12
4124 #define NINDIRECT (BSIZE / sizeof(uint))
4125 #define MAXFILE (NDIRECT + NINDIRECT)
4126 
4127 
4128 struct dinode {
4129   short type;           
4130   short major;          
4131   short minor;          
4132   short nlink;          
4133   uint size;            
4134   uint addrs[NDIRECT+1];   
4135 };
4136 
4137 
4138 
4139 
4140 
4141 
4142 
4143 
4144 
4145 
4146 
4147 
4148 
4149 
4150 
4151 #define IPB           (BSIZE / sizeof(struct dinode))
4152 
4153 
4154 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
4155 
4156 
4157 #define BPB           (BSIZE*8)
4158 
4159 
4160 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
4161 
4162 
4163 #define DIRSIZ 14
4164 
4165 struct dirent {
4166   ushort inum;
4167   char name[DIRSIZ];
4168 };
4169 
4170 
4171 
4172 
4173 
4174 
4175 
4176 
4177 
4178 
4179 
4180 
4181 
4182 
4183 
4184 
4185 
4186 
4187 
4188 
4189 
4190 
4191 
4192 
4193 
4194 
4195 
4196 
4197 
4198 
4199 
4200 struct file {
4201   enum { FD_NONE, FD_PIPE, FD_INODE } type;
4202   int ref; 
4203   char readable;
4204   char writable;
4205   struct pipe *pipe;
4206   struct inode *ip;
4207   uint off;
4208 };
4209 
4210 
4211 
4212 struct inode {
4213   uint dev;           
4214   uint inum;          
4215   int ref;            
4216   struct sleeplock lock; 
4217   int valid;          
4218 
4219   short type;         
4220   short major;
4221   short minor;
4222   short nlink;
4223   uint size;
4224   uint addrs[NDIRECT+1];
4225 };
4226 
4227 
4228 
4229 struct devsw {
4230   int (*read)(struct inode*, char*, int);
4231   int (*write)(struct inode*, char*, int);
4232 };
4233 
4234 extern struct devsw devsw[];
4235 
4236 #define CONSOLE 1
4237 
4238 
4239 
4240 
4241 
4242 
4243 
4244 
4245 
4246 
4247 
4248 
4249 
4250 
4251 
4252 #include "types.h"
4253 #include "defs.h"
4254 #include "param.h"
4255 #include "memlayout.h"
4256 #include "mmu.h"
4257 #include "proc.h"
4258 #include "x86.h"
4259 #include "traps.h"
4260 #include "spinlock.h"
4261 #include "sleeplock.h"
4262 #include "fs.h"
4263 #include "buf.h"
4264 
4265 #define SECTOR_SIZE   512
4266 #define IDE_BSY       0x80
4267 #define IDE_DRDY      0x40
4268 #define IDE_DF        0x20
4269 #define IDE_ERR       0x01
4270 
4271 #define IDE_CMD_READ  0x20
4272 #define IDE_CMD_WRITE 0x30
4273 #define IDE_CMD_RDMUL 0xc4
4274 #define IDE_CMD_WRMUL 0xc5
4275 
4276 
4277 
4278 
4279 
4280 static struct spinlock idelock;
4281 static struct buf *idequeue;
4282 
4283 static int havedisk1;
4284 static void idestart(struct buf*);
4285 
4286 
4287 static int
4288 idewait(int checkerr)
4289 {
4290   int r;
4291 
4292   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
4293     ;
4294   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
4295     return -1;
4296   return 0;
4297 }
4298 
4299 
4300 void
4301 ideinit(void)
4302 {
4303   int i;
4304 
4305   initlock(&idelock, "ide");
4306   ioapicenable(IRQ_IDE, ncpu - 1);
4307   idewait(0);
4308 
4309   
4310   outb(0x1f6, 0xe0 | (1<<4));
4311   for(i=0; i<1000; i++){
4312     if(inb(0x1f7) != 0){
4313       havedisk1 = 1;
4314       break;
4315     }
4316   }
4317 
4318   
4319   outb(0x1f6, 0xe0 | (0<<4));
4320 }
4321 
4322 
4323 static void
4324 idestart(struct buf *b)
4325 {
4326   if(b == 0)
4327     panic("idestart");
4328   if(b->blockno >= FSSIZE)
4329     panic("incorrect blockno");
4330   int sector_per_block =  BSIZE/SECTOR_SIZE;
4331   int sector = b->blockno * sector_per_block;
4332   int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
4333   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
4334 
4335   if (sector_per_block > 7) panic("idestart");
4336 
4337   idewait(0);
4338   outb(0x3f6, 0);  
4339   outb(0x1f2, sector_per_block);  
4340   outb(0x1f3, sector & 0xff);
4341   outb(0x1f4, (sector >> 8) & 0xff);
4342   outb(0x1f5, (sector >> 16) & 0xff);
4343   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
4344   if(b->flags & B_DIRTY){
4345     outb(0x1f7, write_cmd);
4346     outsl(0x1f0, b->data, BSIZE/4);
4347   } else {
4348     outb(0x1f7, read_cmd);
4349   }
4350 }
4351 
4352 
4353 void
4354 ideintr(void)
4355 {
4356   struct buf *b;
4357 
4358   
4359   acquire(&idelock);
4360 
4361   if((b = idequeue) == 0){
4362     release(&idelock);
4363     return;
4364   }
4365   idequeue = b->qnext;
4366 
4367   
4368   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
4369     insl(0x1f0, b->data, BSIZE/4);
4370 
4371   
4372   b->flags |= B_VALID;
4373   b->flags &= ~B_DIRTY;
4374   wakeup(b);
4375 
4376   
4377   if(idequeue != 0)
4378     idestart(idequeue);
4379 
4380   release(&idelock);
4381 }
4382 
4383 
4384 
4385 
4386 
4387 
4388 
4389 
4390 
4391 
4392 
4393 
4394 
4395 
4396 
4397 
4398 
4399 
4400 
4401 
4402 
4403 void
4404 iderw(struct buf *b)
4405 {
4406   struct buf **pp;
4407 
4408   if(!holdingsleep(&b->lock))
4409     panic("iderw: buf not locked");
4410   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
4411     panic("iderw: nothing to do");
4412   if(b->dev != 0 && !havedisk1)
4413     panic("iderw: ide disk 1 not present");
4414 
4415   acquire(&idelock);  
4416 
4417   
4418   b->qnext = 0;
4419   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
4420     ;
4421   *pp = b;
4422 
4423   
4424   if(idequeue == b)
4425     idestart(b);
4426 
4427   
4428   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
4429     sleep(b, &idelock);
4430   }
4431 
4432 
4433   release(&idelock);
4434 }
4435 
4436 
4437 
4438 
4439 
4440 
4441 
4442 
4443 
4444 
4445 
4446 
4447 
4448 
4449 
4450 
4451 
4452 
4453 
4454 
4455 
4456 
4457 
4458 
4459 
4460 
4461 
4462 
4463 
4464 
4465 
4466 
4467 
4468 
4469 
4470 #include "types.h"
4471 #include "defs.h"
4472 #include "param.h"
4473 #include "spinlock.h"
4474 #include "sleeplock.h"
4475 #include "fs.h"
4476 #include "buf.h"
4477 
4478 struct {
4479   struct spinlock lock;
4480   struct buf buf[NBUF];
4481 
4482   
4483   
4484   struct buf head;
4485 } bcache;
4486 
4487 void
4488 binit(void)
4489 {
4490   struct buf *b;
4491 
4492   initlock(&bcache.lock, "bcache");
4493 
4494 
4495 
4496 
4497 
4498 
4499 
4500   
4501   bcache.head.prev = &bcache.head;
4502   bcache.head.next = &bcache.head;
4503   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
4504     b->next = bcache.head.next;
4505     b->prev = &bcache.head;
4506     initsleeplock(&b->lock, "buffer");
4507     bcache.head.next->prev = b;
4508     bcache.head.next = b;
4509   }
4510 }
4511 
4512 
4513 
4514 
4515 static struct buf*
4516 bget(uint dev, uint blockno)
4517 {
4518   struct buf *b;
4519 
4520   acquire(&bcache.lock);
4521 
4522   
4523   for(b = bcache.head.next; b != &bcache.head; b = b->next){
4524     if(b->dev == dev && b->blockno == blockno){
4525       b->refcnt++;
4526       release(&bcache.lock);
4527       acquiresleep(&b->lock);
4528       return b;
4529     }
4530   }
4531 
4532   
4533   
4534   
4535   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
4536     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
4537       b->dev = dev;
4538       b->blockno = blockno;
4539       b->flags = 0;
4540       b->refcnt = 1;
4541       release(&bcache.lock);
4542       acquiresleep(&b->lock);
4543       return b;
4544     }
4545   }
4546   panic("bget: no buffers");
4547 }
4548 
4549 
4550 
4551 struct buf*
4552 bread(uint dev, uint blockno)
4553 {
4554   struct buf *b;
4555 
4556   b = bget(dev, blockno);
4557   if((b->flags & B_VALID) == 0) {
4558     iderw(b);
4559   }
4560   return b;
4561 }
4562 
4563 
4564 void
4565 bwrite(struct buf *b)
4566 {
4567   if(!holdingsleep(&b->lock))
4568     panic("bwrite");
4569   b->flags |= B_DIRTY;
4570   iderw(b);
4571 }
4572 
4573 
4574 
4575 void
4576 brelse(struct buf *b)
4577 {
4578   if(!holdingsleep(&b->lock))
4579     panic("brelse");
4580 
4581   releasesleep(&b->lock);
4582 
4583   acquire(&bcache.lock);
4584   b->refcnt--;
4585   if (b->refcnt == 0) {
4586     
4587     b->next->prev = b->prev;
4588     b->prev->next = b->next;
4589     b->next = bcache.head.next;
4590     b->prev = &bcache.head;
4591     bcache.head.next->prev = b;
4592     bcache.head.next = b;
4593   }
4594 
4595   release(&bcache.lock);
4596 }
4597 
4598 
4599 
4600 
4601 
4602 
4603 
4604 
4605 
4606 
4607 
4608 
4609 
4610 
4611 
4612 
4613 
4614 
4615 
4616 
4617 
4618 
4619 
4620 
4621 
4622 
4623 
4624 
4625 
4626 
4627 
4628 
4629 
4630 
4631 
4632 
4633 
4634 
4635 
4636 
4637 
4638 
4639 
4640 
4641 
4642 
4643 
4644 
4645 
4646 
4647 
4648 
4649 
4650 
4651 
4652 #include "types.h"
4653 #include "defs.h"
4654 #include "param.h"
4655 #include "x86.h"
4656 #include "memlayout.h"
4657 #include "mmu.h"
4658 #include "proc.h"
4659 #include "spinlock.h"
4660 #include "sleeplock.h"
4661 
4662 void
4663 initsleeplock(struct sleeplock *lk, char *name)
4664 {
4665   initlock(&lk->lk, "sleep lock");
4666   lk->name = name;
4667   lk->locked = 0;
4668   lk->pid = 0;
4669 }
4670 
4671 void
4672 acquiresleep(struct sleeplock *lk)
4673 {
4674   acquire(&lk->lk);
4675   while (lk->locked) {
4676     sleep(lk, &lk->lk);
4677   }
4678   lk->locked = 1;
4679   lk->pid = myproc()->pid;
4680   release(&lk->lk);
4681 }
4682 
4683 void
4684 releasesleep(struct sleeplock *lk)
4685 {
4686   acquire(&lk->lk);
4687   lk->locked = 0;
4688   lk->pid = 0;
4689   wakeup(lk);
4690   release(&lk->lk);
4691 }
4692 
4693 
4694 
4695 
4696 
4697 
4698 
4699 
4700 int
4701 holdingsleep(struct sleeplock *lk)
4702 {
4703   int r;
4704 
4705   acquire(&lk->lk);
4706   r = lk->locked && (lk->pid == myproc()->pid);
4707   release(&lk->lk);
4708   return r;
4709 }
4710 
4711 
4712 
4713 
4714 
4715 
4716 
4717 
4718 
4719 
4720 
4721 
4722 
4723 
4724 
4725 
4726 
4727 
4728 
4729 
4730 
4731 
4732 
4733 
4734 
4735 
4736 
4737 
4738 
4739 
4740 
4741 
4742 
4743 
4744 
4745 
4746 
4747 
4748 
4749 
4750 #include "types.h"
4751 #include "defs.h"
4752 #include "param.h"
4753 #include "spinlock.h"
4754 #include "sleeplock.h"
4755 #include "fs.h"
4756 #include "buf.h"
4757 
4758 
4759 
4760 
4761 
4762 
4763 
4764 
4765 
4766 
4767 
4768 
4769 
4770 
4771 
4772 
4773 
4774 
4775 
4776 
4777 
4778 
4779 
4780 
4781 
4782 
4783 struct logheader {
4784   int n;
4785   int block[LOGSIZE];
4786 };
4787 
4788 struct log {
4789   struct spinlock lock;
4790   int start;
4791   int size;
4792   int outstanding; 
4793   int committing;  
4794   int dev;
4795   struct logheader lh;
4796 };
4797 
4798 
4799 
4800 struct log log;
4801 
4802 static void recover_from_log(void);
4803 static void commit();
4804 
4805 void
4806 initlog(int dev)
4807 {
4808   if (sizeof(struct logheader) >= BSIZE)
4809     panic("initlog: too big logheader");
4810 
4811   struct superblock sb;
4812   initlock(&log.lock, "log");
4813   readsb(dev, &sb);
4814   log.start = sb.logstart;
4815   log.size = sb.nlog;
4816   log.dev = dev;
4817   recover_from_log();
4818 }
4819 
4820 
4821 static void
4822 install_trans(void)
4823 {
4824   int tail;
4825 
4826   for (tail = 0; tail < log.lh.n; tail++) {
4827     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
4828     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
4829     memmove(dbuf->data, lbuf->data, BSIZE);  
4830     bwrite(dbuf);  
4831     brelse(lbuf);
4832     brelse(dbuf);
4833   }
4834 }
4835 
4836 
4837 static void
4838 read_head(void)
4839 {
4840   struct buf *buf = bread(log.dev, log.start);
4841   struct logheader *lh = (struct logheader *) (buf->data);
4842   int i;
4843   log.lh.n = lh->n;
4844   for (i = 0; i < log.lh.n; i++) {
4845     log.lh.block[i] = lh->block[i];
4846   }
4847   brelse(buf);
4848 }
4849 
4850 
4851 
4852 
4853 static void
4854 write_head(void)
4855 {
4856   struct buf *buf = bread(log.dev, log.start);
4857   struct logheader *hb = (struct logheader *) (buf->data);
4858   int i;
4859   hb->n = log.lh.n;
4860   for (i = 0; i < log.lh.n; i++) {
4861     hb->block[i] = log.lh.block[i];
4862   }
4863   bwrite(buf);
4864   brelse(buf);
4865 }
4866 
4867 static void
4868 recover_from_log(void)
4869 {
4870   read_head();
4871   install_trans(); 
4872   log.lh.n = 0;
4873   write_head(); 
4874 }
4875 
4876 
4877 void
4878 begin_op(void)
4879 {
4880   acquire(&log.lock);
4881   while(1){
4882     if(log.committing){
4883       sleep(&log, &log.lock);
4884     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
4885       
4886       sleep(&log, &log.lock);
4887     } else {
4888       log.outstanding += 1;
4889       release(&log.lock);
4890       break;
4891     }
4892   }
4893 }
4894 
4895 
4896 
4897 
4898 
4899 
4900 
4901 
4902 void
4903 end_op(void)
4904 {
4905   int do_commit = 0;
4906 
4907   acquire(&log.lock);
4908   log.outstanding -= 1;
4909   if(log.committing)
4910     panic("log.committing");
4911   if(log.outstanding == 0){
4912     do_commit = 1;
4913     log.committing = 1;
4914   } else {
4915     
4916     
4917     
4918     wakeup(&log);
4919   }
4920   release(&log.lock);
4921 
4922   if(do_commit){
4923     
4924     
4925     commit();
4926     acquire(&log.lock);
4927     log.committing = 0;
4928     wakeup(&log);
4929     release(&log.lock);
4930   }
4931 }
4932 
4933 
4934 static void
4935 write_log(void)
4936 {
4937   int tail;
4938 
4939   for (tail = 0; tail < log.lh.n; tail++) {
4940     struct buf *to = bread(log.dev, log.start+tail+1); 
4941     struct buf *from = bread(log.dev, log.lh.block[tail]); 
4942     memmove(to->data, from->data, BSIZE);
4943     bwrite(to);  
4944     brelse(from);
4945     brelse(to);
4946   }
4947 }
4948 
4949 
4950 static void
4951 commit()
4952 {
4953   if (log.lh.n > 0) {
4954     write_log();     
4955     write_head();    
4956     install_trans(); 
4957     log.lh.n = 0;
4958     write_head();    
4959   }
4960 }
4961 
4962 
4963 
4964 
4965 
4966 
4967 
4968 
4969 
4970 
4971 void
4972 log_write(struct buf *b)
4973 {
4974   int i;
4975 
4976   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
4977     panic("too big a transaction");
4978   if (log.outstanding < 1)
4979     panic("log_write outside of trans");
4980 
4981   acquire(&log.lock);
4982   for (i = 0; i < log.lh.n; i++) {
4983     if (log.lh.block[i] == b->blockno)   
4984       break;
4985   }
4986   log.lh.block[i] = b->blockno;
4987   if (i == log.lh.n)
4988     log.lh.n++;
4989   b->flags |= B_DIRTY; 
4990   release(&log.lock);
4991 }
4992 
4993 
4994 
4995 
4996 
4997 
4998 
4999 
5000 
5001 
5002 
5003 
5004 
5005 
5006 
5007 
5008 
5009 
5010 
5011 #include "types.h"
5012 #include "defs.h"
5013 #include "param.h"
5014 #include "stat.h"
5015 #include "mmu.h"
5016 #include "proc.h"
5017 #include "spinlock.h"
5018 #include "sleeplock.h"
5019 #include "fs.h"
5020 #include "buf.h"
5021 #include "file.h"
5022 
5023 #define min(a, b) ((a) < (b) ? (a) : (b))
5024 static void itrunc(struct inode*);
5025 
5026 
5027 struct superblock sb;
5028 
5029 
5030 void
5031 readsb(int dev, struct superblock *sb)
5032 {
5033   struct buf *bp;
5034 
5035   bp = bread(dev, 1);
5036   memmove(sb, bp->data, sizeof(*sb));
5037   brelse(bp);
5038 }
5039 
5040 
5041 
5042 
5043 
5044 
5045 
5046 
5047 
5048 
5049 
5050 
5051 static void
5052 bzero(int dev, int bno)
5053 {
5054   struct buf *bp;
5055 
5056   bp = bread(dev, bno);
5057   memset(bp->data, 0, BSIZE);
5058   log_write(bp);
5059   brelse(bp);
5060 }
5061 
5062 
5063 
5064 
5065 static uint
5066 balloc(uint dev)
5067 {
5068   int b, bi, m;
5069   struct buf *bp;
5070 
5071   bp = 0;
5072   for(b = 0; b < sb.size; b += BPB){
5073     bp = bread(dev, BBLOCK(b, sb));
5074     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
5075       m = 1 << (bi % 8);
5076       if((bp->data[bi/8] & m) == 0){  
5077         bp->data[bi/8] |= m;  
5078         log_write(bp);
5079         brelse(bp);
5080         bzero(dev, b + bi);
5081         return b + bi;
5082       }
5083     }
5084     brelse(bp);
5085   }
5086   panic("balloc: out of blocks");
5087 }
5088 
5089 
5090 
5091 
5092 
5093 
5094 
5095 
5096 
5097 
5098 
5099 
5100 
5101 static void
5102 bfree(int dev, uint b)
5103 {
5104   struct buf *bp;
5105   int bi, m;
5106 
5107   bp = bread(dev, BBLOCK(b, sb));
5108   bi = b % BPB;
5109   m = 1 << (bi % 8);
5110   if((bp->data[bi/8] & m) == 0)
5111     panic("freeing free block");
5112   bp->data[bi/8] &= ~m;
5113   log_write(bp);
5114   brelse(bp);
5115 }
5116 
5117 
5118 
5119 
5120 
5121 
5122 
5123 
5124 
5125 
5126 
5127 
5128 
5129 
5130 
5131 
5132 
5133 
5134 
5135 
5136 
5137 
5138 
5139 
5140 
5141 
5142 
5143 
5144 
5145 
5146 
5147 
5148 
5149 
5150 
5151 
5152 
5153 
5154 
5155 
5156 
5157 
5158 
5159 
5160 
5161 
5162 
5163 
5164 
5165 
5166 
5167 
5168 
5169 
5170 
5171 
5172 
5173 
5174 
5175 
5176 
5177 
5178 
5179 
5180 
5181 
5182 
5183 
5184 
5185 
5186 struct {
5187   struct spinlock lock;
5188   struct inode inode[NINODE];
5189 } icache;
5190 
5191 void
5192 iinit(int dev)
5193 {
5194   int i = 0;
5195 
5196   initlock(&icache.lock, "icache");
5197   for(i = 0; i < NINODE; i++) {
5198     initsleeplock(&icache.inode[i].lock, "inode");
5199   }
5200   readsb(dev, &sb);
5201   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
5202  inodestart %d bmap start %d\n", sb.size, sb.nblocks,
5203           sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
5204           sb.bmapstart);
5205 }
5206 
5207 static struct inode* iget(uint dev, uint inum);
5208 
5209 
5210 
5211 
5212 
5213 
5214 
5215 
5216 
5217 
5218 
5219 
5220 
5221 
5222 
5223 
5224 
5225 
5226 
5227 
5228 
5229 
5230 
5231 
5232 
5233 
5234 
5235 
5236 
5237 
5238 
5239 
5240 
5241 
5242 
5243 
5244 
5245 
5246 
5247 
5248 
5249 
5250 
5251 
5252 
5253 struct inode*
5254 ialloc(uint dev, short type)
5255 {
5256   int inum;
5257   struct buf *bp;
5258   struct dinode *dip;
5259 
5260   for(inum = 1; inum < sb.ninodes; inum++){
5261     bp = bread(dev, IBLOCK(inum, sb));
5262     dip = (struct dinode*)bp->data + inum%IPB;
5263     if(dip->type == 0){  
5264       memset(dip, 0, sizeof(*dip));
5265       dip->type = type;
5266       log_write(bp);   
5267       brelse(bp);
5268       return iget(dev, inum);
5269     }
5270     brelse(bp);
5271   }
5272   panic("ialloc: no inodes");
5273 }
5274 
5275 
5276 
5277 
5278 
5279 void
5280 iupdate(struct inode *ip)
5281 {
5282   struct buf *bp;
5283   struct dinode *dip;
5284 
5285   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5286   dip = (struct dinode*)bp->data + ip->inum%IPB;
5287   dip->type = ip->type;
5288   dip->major = ip->major;
5289   dip->minor = ip->minor;
5290   dip->nlink = ip->nlink;
5291   dip->size = ip->size;
5292   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
5293   log_write(bp);
5294   brelse(bp);
5295 }
5296 
5297 
5298 
5299 
5300 
5301 
5302 
5303 static struct inode*
5304 iget(uint dev, uint inum)
5305 {
5306   struct inode *ip, *empty;
5307 
5308   acquire(&icache.lock);
5309 
5310   
5311   empty = 0;
5312   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
5313     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
5314       ip->ref++;
5315       release(&icache.lock);
5316       return ip;
5317     }
5318     if(empty == 0 && ip->ref == 0)    
5319       empty = ip;
5320   }
5321 
5322   
5323   if(empty == 0)
5324     panic("iget: no inodes");
5325 
5326   ip = empty;
5327   ip->dev = dev;
5328   ip->inum = inum;
5329   ip->ref = 1;
5330   ip->valid = 0;
5331   release(&icache.lock);
5332 
5333   return ip;
5334 }
5335 
5336 
5337 
5338 struct inode*
5339 idup(struct inode *ip)
5340 {
5341   acquire(&icache.lock);
5342   ip->ref++;
5343   release(&icache.lock);
5344   return ip;
5345 }
5346 
5347 
5348 
5349 
5350 
5351 
5352 void
5353 ilock(struct inode *ip)
5354 {
5355   struct buf *bp;
5356   struct dinode *dip;
5357 
5358   if(ip == 0 || ip->ref < 1)
5359     panic("ilock");
5360 
5361   acquiresleep(&ip->lock);
5362 
5363   if(ip->valid == 0){
5364     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5365     dip = (struct dinode*)bp->data + ip->inum%IPB;
5366     ip->type = dip->type;
5367     ip->major = dip->major;
5368     ip->minor = dip->minor;
5369     ip->nlink = dip->nlink;
5370     ip->size = dip->size;
5371     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
5372     brelse(bp);
5373     ip->valid = 1;
5374     if(ip->type == 0)
5375       panic("ilock: no type");
5376   }
5377 }
5378 
5379 
5380 void
5381 iunlock(struct inode *ip)
5382 {
5383   if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
5384     panic("iunlock");
5385 
5386   releasesleep(&ip->lock);
5387 }
5388 
5389 
5390 
5391 
5392 
5393 
5394 
5395 
5396 
5397 
5398 
5399 
5400 
5401 
5402 
5403 
5404 
5405 
5406 
5407 void
5408 iput(struct inode *ip)
5409 {
5410   acquiresleep(&ip->lock);
5411   if(ip->valid && ip->nlink == 0){
5412     acquire(&icache.lock);
5413     int r = ip->ref;
5414     release(&icache.lock);
5415     if(r == 1){
5416       
5417       itrunc(ip);
5418       ip->type = 0;
5419       iupdate(ip);
5420       ip->valid = 0;
5421     }
5422   }
5423   releasesleep(&ip->lock);
5424 
5425   acquire(&icache.lock);
5426   ip->ref--;
5427   release(&icache.lock);
5428 }
5429 
5430 
5431 void
5432 iunlockput(struct inode *ip)
5433 {
5434   iunlock(ip);
5435   iput(ip);
5436 }
5437 
5438 
5439 
5440 
5441 
5442 
5443 
5444 
5445 
5446 
5447 
5448 
5449 
5450 
5451 
5452 
5453 
5454 
5455 
5456 
5457 
5458 
5459 static uint
5460 bmap(struct inode *ip, uint bn)
5461 {
5462   uint addr, *a;
5463   struct buf *bp;
5464 
5465   if(bn < NDIRECT){
5466     if((addr = ip->addrs[bn]) == 0)
5467       ip->addrs[bn] = addr = balloc(ip->dev);
5468     return addr;
5469   }
5470   bn -= NDIRECT;
5471 
5472   if(bn < NINDIRECT){
5473     
5474     if((addr = ip->addrs[NDIRECT]) == 0)
5475       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
5476     bp = bread(ip->dev, addr);
5477     a = (uint*)bp->data;
5478     if((addr = a[bn]) == 0){
5479       a[bn] = addr = balloc(ip->dev);
5480       log_write(bp);
5481     }
5482     brelse(bp);
5483     return addr;
5484   }
5485 
5486   panic("bmap: out of range");
5487 }
5488 
5489 
5490 
5491 
5492 
5493 
5494 
5495 
5496 
5497 
5498 
5499 
5500 
5501 
5502 
5503 
5504 
5505 static void
5506 itrunc(struct inode *ip)
5507 {
5508   int i, j;
5509   struct buf *bp;
5510   uint *a;
5511 
5512   for(i = 0; i < NDIRECT; i++){
5513     if(ip->addrs[i]){
5514       bfree(ip->dev, ip->addrs[i]);
5515       ip->addrs[i] = 0;
5516     }
5517   }
5518 
5519   if(ip->addrs[NDIRECT]){
5520     bp = bread(ip->dev, ip->addrs[NDIRECT]);
5521     a = (uint*)bp->data;
5522     for(j = 0; j < NINDIRECT; j++){
5523       if(a[j])
5524         bfree(ip->dev, a[j]);
5525     }
5526     brelse(bp);
5527     bfree(ip->dev, ip->addrs[NDIRECT]);
5528     ip->addrs[NDIRECT] = 0;
5529   }
5530 
5531   ip->size = 0;
5532   iupdate(ip);
5533 }
5534 
5535 
5536 
5537 void
5538 stati(struct inode *ip, struct stat *st)
5539 {
5540   st->dev = ip->dev;
5541   st->ino = ip->inum;
5542   st->type = ip->type;
5543   st->nlink = ip->nlink;
5544   st->size = ip->size;
5545 }
5546 
5547 
5548 
5549 
5550 
5551 
5552 int
5553 readi(struct inode *ip, char *dst, uint off, uint n)
5554 {
5555   uint tot, m;
5556   struct buf *bp;
5557 
5558   if(ip->type == T_DEV){
5559     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
5560       return -1;
5561     return devsw[ip->major].read(ip, dst, n);
5562   }
5563 
5564   if(off > ip->size || off + n < off)
5565     return -1;
5566   if(off + n > ip->size)
5567     n = ip->size - off;
5568 
5569   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
5570     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5571     m = min(n - tot, BSIZE - off%BSIZE);
5572     memmove(dst, bp->data + off%BSIZE, m);
5573     brelse(bp);
5574   }
5575   return n;
5576 }
5577 
5578 
5579 
5580 
5581 
5582 
5583 
5584 
5585 
5586 
5587 
5588 
5589 
5590 
5591 
5592 
5593 
5594 
5595 
5596 
5597 
5598 
5599 
5600 
5601 
5602 int
5603 writei(struct inode *ip, char *src, uint off, uint n)
5604 {
5605   uint tot, m;
5606   struct buf *bp;
5607 
5608   if(ip->type == T_DEV){
5609     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
5610       return -1;
5611     return devsw[ip->major].write(ip, src, n);
5612   }
5613 
5614   if(off > ip->size || off + n < off)
5615     return -1;
5616   if(off + n > MAXFILE*BSIZE)
5617     return -1;
5618 
5619   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
5620     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5621     m = min(n - tot, BSIZE - off%BSIZE);
5622     memmove(bp->data + off%BSIZE, src, m);
5623     log_write(bp);
5624     brelse(bp);
5625   }
5626 
5627   if(n > 0 && off > ip->size){
5628     ip->size = off;
5629     iupdate(ip);
5630   }
5631   return n;
5632 }
5633 
5634 
5635 
5636 
5637 
5638 
5639 
5640 
5641 
5642 
5643 
5644 
5645 
5646 
5647 
5648 
5649 
5650 
5651 
5652 int
5653 namecmp(const char *s, const char *t)
5654 {
5655   return strncmp(s, t, DIRSIZ);
5656 }
5657 
5658 
5659 
5660 struct inode*
5661 dirlookup(struct inode *dp, char *name, uint *poff)
5662 {
5663   uint off, inum;
5664   struct dirent de;
5665 
5666   if(dp->type != T_DIR)
5667     panic("dirlookup not DIR");
5668 
5669   for(off = 0; off < dp->size; off += sizeof(de)){
5670     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5671       panic("dirlookup read");
5672     if(de.inum == 0)
5673       continue;
5674     if(namecmp(name, de.name) == 0){
5675       
5676       if(poff)
5677         *poff = off;
5678       inum = de.inum;
5679       return iget(dp->dev, inum);
5680     }
5681   }
5682 
5683   return 0;
5684 }
5685 
5686 
5687 
5688 
5689 
5690 
5691 
5692 
5693 
5694 
5695 
5696 
5697 
5698 
5699 
5700 
5701 int
5702 dirlink(struct inode *dp, char *name, uint inum)
5703 {
5704   int off;
5705   struct dirent de;
5706   struct inode *ip;
5707 
5708   
5709   if((ip = dirlookup(dp, name, 0)) != 0){
5710     iput(ip);
5711     return -1;
5712   }
5713 
5714   
5715   for(off = 0; off < dp->size; off += sizeof(de)){
5716     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5717       panic("dirlink read");
5718     if(de.inum == 0)
5719       break;
5720   }
5721 
5722   strncpy(de.name, name, DIRSIZ);
5723   de.inum = inum;
5724   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5725     panic("dirlink");
5726 
5727   return 0;
5728 }
5729 
5730 
5731 
5732 
5733 
5734 
5735 
5736 
5737 
5738 
5739 
5740 
5741 
5742 
5743 
5744 
5745 
5746 
5747 
5748 
5749 
5750 
5751 
5752 
5753 
5754 
5755 
5756 
5757 
5758 
5759 
5760 
5761 
5762 
5763 
5764 static char*
5765 skipelem(char *path, char *name)
5766 {
5767   char *s;
5768   int len;
5769 
5770   while(*path == '/')
5771     path++;
5772   if(*path == 0)
5773     return 0;
5774   s = path;
5775   while(*path != '/' && *path != 0)
5776     path++;
5777   len = path - s;
5778   if(len >= DIRSIZ)
5779     memmove(name, s, DIRSIZ);
5780   else {
5781     memmove(name, s, len);
5782     name[len] = 0;
5783   }
5784   while(*path == '/')
5785     path++;
5786   return path;
5787 }
5788 
5789 
5790 
5791 
5792 
5793 
5794 
5795 
5796 
5797 
5798 
5799 
5800 
5801 
5802 
5803 
5804 static struct inode*
5805 namex(char *path, int nameiparent, char *name)
5806 {
5807   struct inode *ip, *next;
5808 
5809   if(*path == '/')
5810     ip = iget(ROOTDEV, ROOTINO);
5811   else
5812     ip = idup(myproc()->cwd);
5813 
5814   while((path = skipelem(path, name)) != 0){
5815     ilock(ip);
5816     if(ip->type != T_DIR){
5817       iunlockput(ip);
5818       return 0;
5819     }
5820     if(nameiparent && *path == '\0'){
5821       
5822       iunlock(ip);
5823       return ip;
5824     }
5825     if((next = dirlookup(ip, name, 0)) == 0){
5826       iunlockput(ip);
5827       return 0;
5828     }
5829     iunlockput(ip);
5830     ip = next;
5831   }
5832   if(nameiparent){
5833     iput(ip);
5834     return 0;
5835   }
5836   return ip;
5837 }
5838 
5839 struct inode*
5840 namei(char *path)
5841 {
5842   char name[DIRSIZ];
5843   return namex(path, 0, name);
5844 }
5845 
5846 
5847 
5848 
5849 
5850 struct inode*
5851 nameiparent(char *path, char *name)
5852 {
5853   return namex(path, 1, name);
5854 }
5855 
5856 
5857 
5858 
5859 
5860 
5861 
5862 
5863 
5864 
5865 
5866 
5867 
5868 
5869 
5870 
5871 
5872 
5873 
5874 
5875 
5876 
5877 
5878 
5879 
5880 
5881 
5882 
5883 
5884 
5885 
5886 
5887 
5888 
5889 
5890 
5891 
5892 
5893 
5894 
5895 
5896 
5897 
5898 
5899 
5900 
5901 
5902 
5903 
5904 #include "types.h"
5905 #include "defs.h"
5906 #include "param.h"
5907 #include "fs.h"
5908 #include "spinlock.h"
5909 #include "sleeplock.h"
5910 #include "file.h"
5911 
5912 struct devsw devsw[NDEV];
5913 struct {
5914   struct spinlock lock;
5915   struct file file[NFILE];
5916 } ftable;
5917 
5918 void
5919 fileinit(void)
5920 {
5921   initlock(&ftable.lock, "ftable");
5922 }
5923 
5924 
5925 struct file*
5926 filealloc(void)
5927 {
5928   struct file *f;
5929 
5930   acquire(&ftable.lock);
5931   for(f = ftable.file; f < ftable.file + NFILE; f++){
5932     if(f->ref == 0){
5933       f->ref = 1;
5934       release(&ftable.lock);
5935       return f;
5936     }
5937   }
5938   release(&ftable.lock);
5939   return 0;
5940 }
5941 
5942 
5943 
5944 
5945 
5946 
5947 
5948 
5949 
5950 
5951 struct file*
5952 filedup(struct file *f)
5953 {
5954   acquire(&ftable.lock);
5955   if(f->ref < 1)
5956     panic("filedup");
5957   f->ref++;
5958   release(&ftable.lock);
5959   return f;
5960 }
5961 
5962 
5963 void
5964 fileclose(struct file *f)
5965 {
5966   struct file ff;
5967 
5968   acquire(&ftable.lock);
5969   if(f->ref < 1)
5970     panic("fileclose");
5971   if(--f->ref > 0){
5972     release(&ftable.lock);
5973     return;
5974   }
5975   ff = *f;
5976   f->ref = 0;
5977   f->type = FD_NONE;
5978   release(&ftable.lock);
5979 
5980   if(ff.type == FD_PIPE)
5981     pipeclose(ff.pipe, ff.writable);
5982   else if(ff.type == FD_INODE){
5983     begin_op();
5984     iput(ff.ip);
5985     end_op();
5986   }
5987 }
5988 
5989 
5990 
5991 
5992 
5993 
5994 
5995 
5996 
5997 
5998 
5999 
6000 
6001 int
6002 filestat(struct file *f, struct stat *st)
6003 {
6004   if(f->type == FD_INODE){
6005     ilock(f->ip);
6006     stati(f->ip, st);
6007     iunlock(f->ip);
6008     return 0;
6009   }
6010   return -1;
6011 }
6012 
6013 
6014 int
6015 fileread(struct file *f, char *addr, int n)
6016 {
6017   int r;
6018 
6019   if(f->readable == 0)
6020     return -1;
6021   if(f->type == FD_PIPE)
6022     return piperead(f->pipe, addr, n);
6023   if(f->type == FD_INODE){
6024     ilock(f->ip);
6025     if((r = readi(f->ip, addr, f->off, n)) > 0)
6026       f->off += r;
6027     iunlock(f->ip);
6028     return r;
6029   }
6030   panic("fileread");
6031 }
6032 
6033 
6034 
6035 
6036 
6037 
6038 
6039 
6040 
6041 
6042 
6043 
6044 
6045 
6046 
6047 
6048 
6049 
6050 
6051 int
6052 filewrite(struct file *f, char *addr, int n)
6053 {
6054   int r;
6055 
6056   if(f->writable == 0)
6057     return -1;
6058   if(f->type == FD_PIPE)
6059     return pipewrite(f->pipe, addr, n);
6060   if(f->type == FD_INODE){
6061     
6062     
6063     
6064     
6065     
6066     
6067     int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
6068     int i = 0;
6069     while(i < n){
6070       int n1 = n - i;
6071       if(n1 > max)
6072         n1 = max;
6073 
6074       begin_op();
6075       ilock(f->ip);
6076       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
6077         f->off += r;
6078       iunlock(f->ip);
6079       end_op();
6080 
6081       if(r < 0)
6082         break;
6083       if(r != n1)
6084         panic("short filewrite");
6085       i += r;
6086     }
6087     return i == n ? n : -1;
6088   }
6089   panic("filewrite");
6090 }
6091 
6092 
6093 
6094 
6095 
6096 
6097 
6098 
6099 
6100 
6101 
6102 
6103 
6104 
6105 
6106 #include "types.h"
6107 #include "defs.h"
6108 #include "param.h"
6109 #include "stat.h"
6110 #include "mmu.h"
6111 #include "proc.h"
6112 #include "fs.h"
6113 #include "spinlock.h"
6114 #include "sleeplock.h"
6115 #include "file.h"
6116 #include "fcntl.h"
6117 
6118 
6119 
6120 static int
6121 argfd(int n, int *pfd, struct file **pf)
6122 {
6123   int fd;
6124   struct file *f;
6125 
6126   if(argint(n, &fd) < 0)
6127     return -1;
6128   if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
6129     return -1;
6130   if(pfd)
6131     *pfd = fd;
6132   if(pf)
6133     *pf = f;
6134   return 0;
6135 }
6136 
6137 
6138 
6139 
6140 
6141 
6142 
6143 
6144 
6145 
6146 
6147 
6148 
6149 
6150 
6151 
6152 static int
6153 fdalloc(struct file *f)
6154 {
6155   int fd;
6156   struct proc *curproc = myproc();
6157 
6158   for(fd = 0; fd < NOFILE; fd++){
6159     if(curproc->ofile[fd] == 0){
6160       curproc->ofile[fd] = f;
6161       return fd;
6162     }
6163   }
6164   return -1;
6165 }
6166 
6167 int
6168 sys_dup(void)
6169 {
6170   struct file *f;
6171   int fd;
6172 
6173   if(argfd(0, 0, &f) < 0)
6174     return -1;
6175   if((fd=fdalloc(f)) < 0)
6176     return -1;
6177   filedup(f);
6178   return fd;
6179 }
6180 
6181 int
6182 sys_read(void)
6183 {
6184   struct file *f;
6185   int n;
6186   char *p;
6187 
6188   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6189     return -1;
6190   return fileread(f, p, n);
6191 }
6192 
6193 
6194 
6195 
6196 
6197 
6198 
6199 
6200 int
6201 sys_write(void)
6202 {
6203   struct file *f;
6204   int n;
6205   char *p;
6206 
6207   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6208     return -1;
6209   return filewrite(f, p, n);
6210 }
6211 
6212 int
6213 sys_close(void)
6214 {
6215   int fd;
6216   struct file *f;
6217 
6218   if(argfd(0, &fd, &f) < 0)
6219     return -1;
6220   myproc()->ofile[fd] = 0;
6221   fileclose(f);
6222   return 0;
6223 }
6224 
6225 int
6226 sys_fstat(void)
6227 {
6228   struct file *f;
6229   struct stat *st;
6230 
6231   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
6232     return -1;
6233   return filestat(f, st);
6234 }
6235 
6236 
6237 
6238 
6239 
6240 
6241 
6242 
6243 
6244 
6245 
6246 
6247 
6248 
6249 
6250 
6251 int
6252 sys_link(void)
6253 {
6254   char name[DIRSIZ], *new, *old;
6255   struct inode *dp, *ip;
6256 
6257   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
6258     return -1;
6259 
6260   begin_op();
6261   if((ip = namei(old)) == 0){
6262     end_op();
6263     return -1;
6264   }
6265 
6266   ilock(ip);
6267   if(ip->type == T_DIR){
6268     iunlockput(ip);
6269     end_op();
6270     return -1;
6271   }
6272 
6273   ip->nlink++;
6274   iupdate(ip);
6275   iunlock(ip);
6276 
6277   if((dp = nameiparent(new, name)) == 0)
6278     goto bad;
6279   ilock(dp);
6280   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
6281     iunlockput(dp);
6282     goto bad;
6283   }
6284   iunlockput(dp);
6285   iput(ip);
6286 
6287   end_op();
6288 
6289   return 0;
6290 
6291 bad:
6292   ilock(ip);
6293   ip->nlink--;
6294   iupdate(ip);
6295   iunlockput(ip);
6296   end_op();
6297   return -1;
6298 }
6299 
6300 
6301 static int
6302 isdirempty(struct inode *dp)
6303 {
6304   int off;
6305   struct dirent de;
6306 
6307   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
6308     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6309       panic("isdirempty: readi");
6310     if(de.inum != 0)
6311       return 0;
6312   }
6313   return 1;
6314 }
6315 
6316 
6317 
6318 
6319 
6320 
6321 
6322 
6323 
6324 
6325 
6326 
6327 
6328 
6329 
6330 
6331 
6332 
6333 
6334 
6335 
6336 
6337 
6338 
6339 
6340 
6341 
6342 
6343 
6344 
6345 
6346 
6347 
6348 
6349 
6350 int
6351 sys_unlink(void)
6352 {
6353   struct inode *ip, *dp;
6354   struct dirent de;
6355   char name[DIRSIZ], *path;
6356   uint off;
6357 
6358   if(argstr(0, &path) < 0)
6359     return -1;
6360 
6361   begin_op();
6362   if((dp = nameiparent(path, name)) == 0){
6363     end_op();
6364     return -1;
6365   }
6366 
6367   ilock(dp);
6368 
6369   
6370   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
6371     goto bad;
6372 
6373   if((ip = dirlookup(dp, name, &off)) == 0)
6374     goto bad;
6375   ilock(ip);
6376 
6377   if(ip->nlink < 1)
6378     panic("unlink: nlink < 1");
6379   if(ip->type == T_DIR && !isdirempty(ip)){
6380     iunlockput(ip);
6381     goto bad;
6382   }
6383 
6384   memset(&de, 0, sizeof(de));
6385   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6386     panic("unlink: writei");
6387   if(ip->type == T_DIR){
6388     dp->nlink--;
6389     iupdate(dp);
6390   }
6391   iunlockput(dp);
6392 
6393   ip->nlink--;
6394   iupdate(ip);
6395   iunlockput(ip);
6396 
6397   end_op();
6398 
6399   return 0;
6400 bad:
6401   iunlockput(dp);
6402   end_op();
6403   return -1;
6404 }
6405 
6406 static struct inode*
6407 create(char *path, short type, short major, short minor)
6408 {
6409   struct inode *ip, *dp;
6410   char name[DIRSIZ];
6411 
6412   if((dp = nameiparent(path, name)) == 0)
6413     return 0;
6414   ilock(dp);
6415 
6416   if((ip = dirlookup(dp, name, 0)) != 0){
6417     iunlockput(dp);
6418     ilock(ip);
6419     if(type == T_FILE && ip->type == T_FILE)
6420       return ip;
6421     iunlockput(ip);
6422     return 0;
6423   }
6424 
6425   if((ip = ialloc(dp->dev, type)) == 0)
6426     panic("create: ialloc");
6427 
6428   ilock(ip);
6429   ip->major = major;
6430   ip->minor = minor;
6431   ip->nlink = 1;
6432   iupdate(ip);
6433 
6434   if(type == T_DIR){  
6435     dp->nlink++;  
6436     iupdate(dp);
6437     
6438     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
6439       panic("create dots");
6440   }
6441 
6442   if(dirlink(dp, name, ip->inum) < 0)
6443     panic("create: dirlink");
6444 
6445   iunlockput(dp);
6446 
6447   return ip;
6448 }
6449 
6450 int
6451 sys_open(void)
6452 {
6453   char *path;
6454   int fd, omode;
6455   struct file *f;
6456   struct inode *ip;
6457 
6458   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
6459     return -1;
6460 
6461   begin_op();
6462 
6463   if(omode & O_CREATE){
6464     ip = create(path, T_FILE, 0, 0);
6465     if(ip == 0){
6466       end_op();
6467       return -1;
6468     }
6469   } else {
6470     if((ip = namei(path)) == 0){
6471       end_op();
6472       return -1;
6473     }
6474     ilock(ip);
6475     if(ip->type == T_DIR && omode != O_RDONLY){
6476       iunlockput(ip);
6477       end_op();
6478       return -1;
6479     }
6480   }
6481 
6482   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
6483     if(f)
6484       fileclose(f);
6485     iunlockput(ip);
6486     end_op();
6487     return -1;
6488   }
6489   iunlock(ip);
6490   end_op();
6491 
6492   f->type = FD_INODE;
6493   f->ip = ip;
6494   f->off = 0;
6495   f->readable = !(omode & O_WRONLY);
6496   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
6497   return fd;
6498 }
6499 
6500 int
6501 sys_mkdir(void)
6502 {
6503   char *path;
6504   struct inode *ip;
6505 
6506   begin_op();
6507   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
6508     end_op();
6509     return -1;
6510   }
6511   iunlockput(ip);
6512   end_op();
6513   return 0;
6514 }
6515 
6516 int
6517 sys_mknod(void)
6518 {
6519   struct inode *ip;
6520   char *path;
6521   int major, minor;
6522 
6523   begin_op();
6524   if((argstr(0, &path)) < 0 ||
6525      argint(1, &major) < 0 ||
6526      argint(2, &minor) < 0 ||
6527      (ip = create(path, T_DEV, major, minor)) == 0){
6528     end_op();
6529     return -1;
6530   }
6531   iunlockput(ip);
6532   end_op();
6533   return 0;
6534 }
6535 
6536 
6537 
6538 
6539 
6540 
6541 
6542 
6543 
6544 
6545 
6546 
6547 
6548 
6549 
6550 int
6551 sys_chdir(void)
6552 {
6553   char *path;
6554   struct inode *ip;
6555   struct proc *curproc = myproc();
6556 
6557   begin_op();
6558   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
6559     end_op();
6560     return -1;
6561   }
6562   ilock(ip);
6563   if(ip->type != T_DIR){
6564     iunlockput(ip);
6565     end_op();
6566     return -1;
6567   }
6568   iunlock(ip);
6569   iput(curproc->cwd);
6570   end_op();
6571   curproc->cwd = ip;
6572   return 0;
6573 }
6574 
6575 int
6576 sys_exec(void)
6577 {
6578   char *path, *argv[MAXARG];
6579   int i;
6580   uint uargv, uarg;
6581 
6582   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
6583     return -1;
6584   }
6585   memset(argv, 0, sizeof(argv));
6586   for(i=0;; i++){
6587     if(i >= NELEM(argv))
6588       return -1;
6589     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
6590       return -1;
6591     if(uarg == 0){
6592       argv[i] = 0;
6593       break;
6594     }
6595     if(fetchstr(uarg, &argv[i]) < 0)
6596       return -1;
6597   }
6598   return exec(path, argv);
6599 }
6600 int
6601 sys_pipe(void)
6602 {
6603   int *fd;
6604   struct file *rf, *wf;
6605   int fd0, fd1;
6606 
6607   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
6608     return -1;
6609   if(pipealloc(&rf, &wf) < 0)
6610     return -1;
6611   fd0 = -1;
6612   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
6613     if(fd0 >= 0)
6614       myproc()->ofile[fd0] = 0;
6615     fileclose(rf);
6616     fileclose(wf);
6617     return -1;
6618   }
6619   fd[0] = fd0;
6620   fd[1] = fd1;
6621   return 0;
6622 }
6623 
6624 
6625 
6626 
6627 
6628 
6629 
6630 
6631 
6632 
6633 
6634 
6635 
6636 
6637 
6638 
6639 
6640 
6641 
6642 
6643 
6644 
6645 
6646 
6647 
6648 
6649 
6650 #include "types.h"
6651 #include "param.h"
6652 #include "memlayout.h"
6653 #include "mmu.h"
6654 #include "proc.h"
6655 #include "defs.h"
6656 #include "x86.h"
6657 #include "elf.h"
6658 
6659 int
6660 exec(char *path, char **argv)
6661 {
6662   char *s, *last;
6663   int i, off;
6664   uint argc, sz, sp, ustack[3+MAXARG+1];
6665   struct elfhdr elf;
6666   struct inode *ip;
6667   struct proghdr ph;
6668   pde_t *pgdir, *oldpgdir;
6669   struct proc *curproc = myproc();
6670 
6671   begin_op();
6672 
6673   if((ip = namei(path)) == 0){
6674     end_op();
6675     cprintf("exec: fail\n");
6676     return -1;
6677   }
6678   ilock(ip);
6679   pgdir = 0;
6680 
6681   
6682   if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
6683     goto bad;
6684   if(elf.magic != ELF_MAGIC)
6685     goto bad;
6686 
6687   if((pgdir = setupkvm()) == 0)
6688     goto bad;
6689 
6690   
6691   sz = 0;
6692   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
6693     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
6694       goto bad;
6695     if(ph.type != ELF_PROG_LOAD)
6696       continue;
6697     if(ph.memsz < ph.filesz)
6698       goto bad;
6699     if(ph.vaddr + ph.memsz < ph.vaddr)
6700       goto bad;
6701     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
6702       goto bad;
6703     if(ph.vaddr % PGSIZE != 0)
6704       goto bad;
6705     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
6706       goto bad;
6707   }
6708   iunlockput(ip);
6709   end_op();
6710   ip = 0;
6711 
6712   
6713   
6714   sz = PGROUNDUP(sz);
6715   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
6716     goto bad;
6717   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
6718   sp = sz;
6719 
6720   
6721   for(argc = 0; argv[argc]; argc++) {
6722     if(argc >= MAXARG)
6723       goto bad;
6724     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
6725     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
6726       goto bad;
6727     ustack[3+argc] = sp;
6728   }
6729   ustack[3+argc] = 0;
6730 
6731   ustack[0] = 0xffffffff;  
6732   ustack[1] = argc;
6733   ustack[2] = sp - (argc+1)*4;  
6734 
6735   sp -= (3+argc+1) * 4;
6736   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
6737     goto bad;
6738 
6739   
6740   for(last=s=path; *s; s++)
6741     if(*s == '/')
6742       last = s+1;
6743   safestrcpy(curproc->name, last, sizeof(curproc->name));
6744 
6745   
6746   oldpgdir = curproc->pgdir;
6747   curproc->pgdir = pgdir;
6748   curproc->sz = sz;
6749   curproc->tf->eip = elf.entry;  
6750   curproc->tf->esp = sp;
6751   switchuvm(curproc);
6752   freevm(oldpgdir);
6753   return 0;
6754 
6755  bad:
6756   if(pgdir)
6757     freevm(pgdir);
6758   if(ip){
6759     iunlockput(ip);
6760     end_op();
6761   }
6762   return -1;
6763 }
6764 
6765 
6766 
6767 
6768 
6769 
6770 
6771 
6772 
6773 
6774 
6775 
6776 
6777 
6778 
6779 
6780 
6781 
6782 
6783 
6784 
6785 
6786 
6787 
6788 
6789 
6790 
6791 
6792 
6793 
6794 
6795 
6796 
6797 
6798 
6799 
6800 #include "types.h"
6801 #include "defs.h"
6802 #include "param.h"
6803 #include "mmu.h"
6804 #include "proc.h"
6805 #include "fs.h"
6806 #include "spinlock.h"
6807 #include "sleeplock.h"
6808 #include "file.h"
6809 
6810 #define PIPESIZE 512
6811 
6812 struct pipe {
6813   struct spinlock lock;
6814   char data[PIPESIZE];
6815   uint nread;     
6816   uint nwrite;    
6817   int readopen;   
6818   int writeopen;  
6819 };
6820 
6821 int
6822 pipealloc(struct file **f0, struct file **f1)
6823 {
6824   struct pipe *p;
6825 
6826   p = 0;
6827   *f0 = *f1 = 0;
6828   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
6829     goto bad;
6830   if((p = (struct pipe*)kalloc()) == 0)
6831     goto bad;
6832   p->readopen = 1;
6833   p->writeopen = 1;
6834   p->nwrite = 0;
6835   p->nread = 0;
6836   initlock(&p->lock, "pipe");
6837   (*f0)->type = FD_PIPE;
6838   (*f0)->readable = 1;
6839   (*f0)->writable = 0;
6840   (*f0)->pipe = p;
6841   (*f1)->type = FD_PIPE;
6842   (*f1)->readable = 0;
6843   (*f1)->writable = 1;
6844   (*f1)->pipe = p;
6845   return 0;
6846 
6847 
6848 
6849 
6850  bad:
6851   if(p)
6852     kfree((char*)p);
6853   if(*f0)
6854     fileclose(*f0);
6855   if(*f1)
6856     fileclose(*f1);
6857   return -1;
6858 }
6859 
6860 void
6861 pipeclose(struct pipe *p, int writable)
6862 {
6863   acquire(&p->lock);
6864   if(writable){
6865     p->writeopen = 0;
6866     wakeup(&p->nread);
6867   } else {
6868     p->readopen = 0;
6869     wakeup(&p->nwrite);
6870   }
6871   if(p->readopen == 0 && p->writeopen == 0){
6872     release(&p->lock);
6873     kfree((char*)p);
6874   } else
6875     release(&p->lock);
6876 }
6877 
6878 
6879 int
6880 pipewrite(struct pipe *p, char *addr, int n)
6881 {
6882   int i;
6883 
6884   acquire(&p->lock);
6885   for(i = 0; i < n; i++){
6886     while(p->nwrite == p->nread + PIPESIZE){  
6887       if(p->readopen == 0 || myproc()->killed){
6888         release(&p->lock);
6889         return -1;
6890       }
6891       wakeup(&p->nread);
6892       sleep(&p->nwrite, &p->lock);  
6893     }
6894     p->data[p->nwrite++ % PIPESIZE] = addr[i];
6895   }
6896   wakeup(&p->nread);  
6897   release(&p->lock);
6898   return n;
6899 }
6900 int
6901 piperead(struct pipe *p, char *addr, int n)
6902 {
6903   int i;
6904 
6905   acquire(&p->lock);
6906   while(p->nread == p->nwrite && p->writeopen){  
6907     if(myproc()->killed){
6908       release(&p->lock);
6909       return -1;
6910     }
6911     sleep(&p->nread, &p->lock); 
6912   }
6913   for(i = 0; i < n; i++){  
6914     if(p->nread == p->nwrite)
6915       break;
6916     addr[i] = p->data[p->nread++ % PIPESIZE];
6917   }
6918   wakeup(&p->nwrite);  
6919   release(&p->lock);
6920   return i;
6921 }
6922 
6923 
6924 
6925 
6926 
6927 
6928 
6929 
6930 
6931 
6932 
6933 
6934 
6935 
6936 
6937 
6938 
6939 
6940 
6941 
6942 
6943 
6944 
6945 
6946 
6947 
6948 
6949 
6950 #include "types.h"
6951 #include "x86.h"
6952 
6953 void*
6954 memset(void *dst, int c, uint n)
6955 {
6956   if ((int)dst%4 == 0 && n%4 == 0){
6957     c &= 0xFF;
6958     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
6959   } else
6960     stosb(dst, c, n);
6961   return dst;
6962 }
6963 
6964 int
6965 memcmp(const void *v1, const void *v2, uint n)
6966 {
6967   const uchar *s1, *s2;
6968 
6969   s1 = v1;
6970   s2 = v2;
6971   while(n-- > 0){
6972     if(*s1 != *s2)
6973       return *s1 - *s2;
6974     s1++, s2++;
6975   }
6976 
6977   return 0;
6978 }
6979 
6980 void*
6981 memmove(void *dst, const void *src, uint n)
6982 {
6983   const char *s;
6984   char *d;
6985 
6986   s = src;
6987   d = dst;
6988   if(s < d && s + n > d){
6989     s += n;
6990     d += n;
6991     while(n-- > 0)
6992       *--d = *--s;
6993   } else
6994     while(n-- > 0)
6995       *d++ = *s++;
6996 
6997   return dst;
6998 }
6999 
7000 
7001 void*
7002 memcpy(void *dst, const void *src, uint n)
7003 {
7004   return memmove(dst, src, n);
7005 }
7006 
7007 int
7008 strncmp(const char *p, const char *q, uint n)
7009 {
7010   while(n > 0 && *p && *p == *q)
7011     n--, p++, q++;
7012   if(n == 0)
7013     return 0;
7014   return (uchar)*p - (uchar)*q;
7015 }
7016 
7017 char*
7018 strncpy(char *s, const char *t, int n)
7019 {
7020   char *os;
7021 
7022   os = s;
7023   while(n-- > 0 && (*s++ = *t++) != 0)
7024     ;
7025   while(n-- > 0)
7026     *s++ = 0;
7027   return os;
7028 }
7029 
7030 
7031 char*
7032 safestrcpy(char *s, const char *t, int n)
7033 {
7034   char *os;
7035 
7036   os = s;
7037   if(n <= 0)
7038     return os;
7039   while(--n > 0 && (*s++ = *t++) != 0)
7040     ;
7041   *s = 0;
7042   return os;
7043 }
7044 
7045 
7046 
7047 
7048 
7049 
7050 int
7051 strlen(const char *s)
7052 {
7053   int n;
7054 
7055   for(n = 0; s[n]; n++)
7056     ;
7057   return n;
7058 }
7059 
7060 
7061 
7062 
7063 
7064 
7065 
7066 
7067 
7068 
7069 
7070 
7071 
7072 
7073 
7074 
7075 
7076 
7077 
7078 
7079 
7080 
7081 
7082 
7083 
7084 
7085 
7086 
7087 
7088 
7089 
7090 
7091 
7092 
7093 
7094 
7095 
7096 
7097 
7098 
7099 
7100 
7101 
7102 struct mp {             
7103   uchar signature[4];           
7104   void *physaddr;               
7105   uchar length;                 
7106   uchar specrev;                
7107   uchar checksum;               
7108   uchar type;                   
7109   uchar imcrp;
7110   uchar reserved[3];
7111 };
7112 
7113 struct mpconf {         
7114   uchar signature[4];           
7115   ushort length;                
7116   uchar version;                
7117   uchar checksum;               
7118   uchar product[20];            
7119   uint *oemtable;               
7120   ushort oemlength;             
7121   ushort entry;                 
7122   uint *lapicaddr;              
7123   ushort xlength;               
7124   uchar xchecksum;              
7125   uchar reserved;
7126 };
7127 
7128 struct mpproc {         
7129   uchar type;                   
7130   uchar apicid;                 
7131   uchar version;                
7132   uchar flags;                  
7133     #define MPBOOT 0x02           
7134   uchar signature[4];           
7135   uint feature;                 
7136   uchar reserved[8];
7137 };
7138 
7139 struct mpioapic {       
7140   uchar type;                   
7141   uchar apicno;                 
7142   uchar version;                
7143   uchar flags;                  
7144   uint *addr;                  
7145 };
7146 
7147 
7148 
7149 
7150 
7151 #define MPPROC    0x00  
7152 #define MPBUS     0x01  
7153 #define MPIOAPIC  0x02  
7154 #define MPIOINTR  0x03  
7155 #define MPLINTR   0x04  
7156 
7157 
7158 
7159 
7160 
7161 
7162 
7163 
7164 
7165 
7166 
7167 
7168 
7169 
7170 
7171 
7172 
7173 
7174 
7175 
7176 
7177 
7178 
7179 
7180 
7181 
7182 
7183 
7184 
7185 
7186 
7187 
7188 
7189 
7190 
7191 
7192 
7193 
7194 
7195 
7196 
7197 
7198 
7199 
7200 
7201 
7202 
7203 
7204 
7205 
7206 
7207 
7208 
7209 
7210 
7211 
7212 
7213 
7214 
7215 
7216 
7217 
7218 
7219 
7220 
7221 
7222 
7223 
7224 
7225 
7226 
7227 
7228 
7229 
7230 
7231 
7232 
7233 
7234 
7235 
7236 
7237 
7238 
7239 
7240 
7241 
7242 
7243 
7244 
7245 
7246 
7247 
7248 
7249 
7250 
7251 
7252 
7253 
7254 #include "types.h"
7255 #include "defs.h"
7256 #include "param.h"
7257 #include "memlayout.h"
7258 #include "mp.h"
7259 #include "x86.h"
7260 #include "mmu.h"
7261 #include "proc.h"
7262 
7263 struct cpu cpus[NCPU];
7264 int ncpu;
7265 uchar ioapicid;
7266 
7267 static uchar
7268 sum(uchar *addr, int len)
7269 {
7270   int i, sum;
7271 
7272   sum = 0;
7273   for(i=0; i<len; i++)
7274     sum += addr[i];
7275   return sum;
7276 }
7277 
7278 
7279 static struct mp*
7280 mpsearch1(uint a, int len)
7281 {
7282   uchar *e, *p, *addr;
7283 
7284   addr = P2V(a);
7285   e = addr+len;
7286   for(p = addr; p < e; p += sizeof(struct mp))
7287     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
7288       return (struct mp*)p;
7289   return 0;
7290 }
7291 
7292 
7293 
7294 
7295 
7296 
7297 
7298 
7299 
7300 
7301 
7302 
7303 
7304 
7305 static struct mp*
7306 mpsearch(void)
7307 {
7308   uchar *bda;
7309   uint p;
7310   struct mp *mp;
7311 
7312   bda = (uchar *) P2V(0x400);
7313   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
7314     if((mp = mpsearch1(p, 1024)))
7315       return mp;
7316   } else {
7317     p = ((bda[0x14]<<8)|bda[0x13])*1024;
7318     if((mp = mpsearch1(p-1024, 1024)))
7319       return mp;
7320   }
7321   return mpsearch1(0xF0000, 0x10000);
7322 }
7323 
7324 
7325 
7326 
7327 
7328 
7329 static struct mpconf*
7330 mpconfig(struct mp **pmp)
7331 {
7332   struct mpconf *conf;
7333   struct mp *mp;
7334 
7335   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
7336     return 0;
7337   conf = (struct mpconf*) P2V((uint) mp->physaddr);
7338   if(memcmp(conf, "PCMP", 4) != 0)
7339     return 0;
7340   if(conf->version != 1 && conf->version != 4)
7341     return 0;
7342   if(sum((uchar*)conf, conf->length) != 0)
7343     return 0;
7344   *pmp = mp;
7345   return conf;
7346 }
7347 
7348 
7349 
7350 void
7351 mpinit(void)
7352 {
7353   uchar *p, *e;
7354   int ismp;
7355   struct mp *mp;
7356   struct mpconf *conf;
7357   struct mpproc *proc;
7358   struct mpioapic *ioapic;
7359 
7360   if((conf = mpconfig(&mp)) == 0)
7361     panic("Expect to run on an SMP");
7362   ismp = 1;
7363   lapic = (uint*)conf->lapicaddr;
7364   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
7365     switch(*p){
7366     case MPPROC:
7367       proc = (struct mpproc*)p;
7368       if(ncpu < NCPU) {
7369         cpus[ncpu].apicid = proc->apicid;  
7370         ncpu++;
7371       }
7372       p += sizeof(struct mpproc);
7373       continue;
7374     case MPIOAPIC:
7375       ioapic = (struct mpioapic*)p;
7376       ioapicid = ioapic->apicno;
7377       p += sizeof(struct mpioapic);
7378       continue;
7379     case MPBUS:
7380     case MPIOINTR:
7381     case MPLINTR:
7382       p += 8;
7383       continue;
7384     default:
7385       ismp = 0;
7386       break;
7387     }
7388   }
7389   if(!ismp)
7390     panic("Didn't find a suitable machine");
7391 
7392   if(mp->imcrp){
7393     
7394     
7395     outb(0x22, 0x70);   
7396     outb(0x23, inb(0x23) | 1);  
7397   }
7398 }
7399 
7400 
7401 
7402 
7403 #include "param.h"
7404 #include "types.h"
7405 #include "defs.h"
7406 #include "date.h"
7407 #include "memlayout.h"
7408 #include "traps.h"
7409 #include "mmu.h"
7410 #include "x86.h"
7411 
7412 
7413 #define ID      (0x0020/4)   
7414 #define VER     (0x0030/4)   
7415 #define TPR     (0x0080/4)   
7416 #define EOI     (0x00B0/4)   
7417 #define SVR     (0x00F0/4)   
7418   #define ENABLE     0x00000100   
7419 #define ESR     (0x0280/4)   
7420 #define ICRLO   (0x0300/4)   
7421   #define INIT       0x00000500   
7422   #define STARTUP    0x00000600   
7423   #define DELIVS     0x00001000   
7424   #define ASSERT     0x00004000   
7425   #define DEASSERT   0x00000000
7426   #define LEVEL      0x00008000   
7427   #define BCAST      0x00080000   
7428   #define BUSY       0x00001000
7429   #define FIXED      0x00000000
7430 #define ICRHI   (0x0310/4)   
7431 #define TIMER   (0x0320/4)   
7432   #define X1         0x0000000B   
7433   #define PERIODIC   0x00020000   
7434 #define PCINT   (0x0340/4)   
7435 #define LINT0   (0x0350/4)   
7436 #define LINT1   (0x0360/4)   
7437 #define ERROR   (0x0370/4)   
7438   #define MASKED     0x00010000   
7439 #define TICR    (0x0380/4)   
7440 #define TCCR    (0x0390/4)   
7441 #define TDCR    (0x03E0/4)   
7442 
7443 volatile uint *lapic;  
7444 
7445 
7446 
7447 
7448 
7449 
7450 static void
7451 lapicw(int index, int value)
7452 {
7453   lapic[index] = value;
7454   lapic[ID];  
7455 }
7456 
7457 void
7458 lapicinit(void)
7459 {
7460   if(!lapic)
7461     return;
7462 
7463   
7464   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
7465 
7466   
7467   
7468   
7469   
7470   lapicw(TDCR, X1);
7471   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
7472   lapicw(TICR, 10000000);
7473 
7474   
7475   lapicw(LINT0, MASKED);
7476   lapicw(LINT1, MASKED);
7477 
7478   
7479   
7480   if(((lapic[VER]>>16) & 0xFF) >= 4)
7481     lapicw(PCINT, MASKED);
7482 
7483   
7484   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
7485 
7486   
7487   lapicw(ESR, 0);
7488   lapicw(ESR, 0);
7489 
7490   
7491   lapicw(EOI, 0);
7492 
7493   
7494   lapicw(ICRHI, 0);
7495   lapicw(ICRLO, BCAST | INIT | LEVEL);
7496   while(lapic[ICRLO] & DELIVS)
7497     ;
7498 
7499 
7500   
7501   lapicw(TPR, 0);
7502 }
7503 
7504 int
7505 lapicid(void)
7506 {
7507   if (!lapic)
7508     return 0;
7509   return lapic[ID] >> 24;
7510 }
7511 
7512 
7513 void
7514 lapiceoi(void)
7515 {
7516   if(lapic)
7517     lapicw(EOI, 0);
7518 }
7519 
7520 
7521 
7522 void
7523 microdelay(int us)
7524 {
7525 }
7526 
7527 #define CMOS_PORT    0x70
7528 #define CMOS_RETURN  0x71
7529 
7530 
7531 
7532 void
7533 lapicstartap(uchar apicid, uint addr)
7534 {
7535   int i;
7536   ushort *wrv;
7537 
7538   
7539   
7540   
7541   outb(CMOS_PORT, 0xF);  
7542   outb(CMOS_PORT+1, 0x0A);
7543   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
7544   wrv[0] = 0;
7545   wrv[1] = addr >> 4;
7546 
7547 
7548 
7549 
7550   
7551   
7552   lapicw(ICRHI, apicid<<24);
7553   lapicw(ICRLO, INIT | LEVEL | ASSERT);
7554   microdelay(200);
7555   lapicw(ICRLO, INIT | LEVEL);
7556   microdelay(100);    
7557 
7558   
7559   
7560   
7561   
7562   
7563   for(i = 0; i < 2; i++){
7564     lapicw(ICRHI, apicid<<24);
7565     lapicw(ICRLO, STARTUP | (addr>>12));
7566     microdelay(200);
7567   }
7568 }
7569 
7570 #define CMOS_STATA   0x0a
7571 #define CMOS_STATB   0x0b
7572 #define CMOS_UIP    (1 << 7)        
7573 
7574 #define SECS    0x00
7575 #define MINS    0x02
7576 #define HOURS   0x04
7577 #define DAY     0x07
7578 #define MONTH   0x08
7579 #define YEAR    0x09
7580 
7581 static uint
7582 cmos_read(uint reg)
7583 {
7584   outb(CMOS_PORT,  reg);
7585   microdelay(200);
7586 
7587   return inb(CMOS_RETURN);
7588 }
7589 
7590 static void
7591 fill_rtcdate(struct rtcdate *r)
7592 {
7593   r->second = cmos_read(SECS);
7594   r->minute = cmos_read(MINS);
7595   r->hour   = cmos_read(HOURS);
7596   r->day    = cmos_read(DAY);
7597   r->month  = cmos_read(MONTH);
7598   r->year   = cmos_read(YEAR);
7599 }
7600 
7601 void
7602 cmostime(struct rtcdate *r)
7603 {
7604   struct rtcdate t1, t2;
7605   int sb, bcd;
7606 
7607   sb = cmos_read(CMOS_STATB);
7608 
7609   bcd = (sb & (1 << 2)) == 0;
7610 
7611   
7612   for(;;) {
7613     fill_rtcdate(&t1);
7614     if(cmos_read(CMOS_STATA) & CMOS_UIP)
7615         continue;
7616     fill_rtcdate(&t2);
7617     if(memcmp(&t1, &t2, sizeof(t1)) == 0)
7618       break;
7619   }
7620 
7621   
7622   if(bcd) {
7623 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
7624     CONV(second);
7625     CONV(minute);
7626     CONV(hour  );
7627     CONV(day   );
7628     CONV(month );
7629     CONV(year  );
7630 #undef     CONV
7631   }
7632 
7633   *r = t1;
7634   r->year += 2000;
7635 }
7636 
7637 
7638 
7639 
7640 
7641 
7642 
7643 
7644 
7645 
7646 
7647 
7648 
7649 
7650 
7651 
7652 
7653 
7654 #include "types.h"
7655 #include "defs.h"
7656 #include "traps.h"
7657 
7658 #define IOAPIC  0xFEC00000   
7659 
7660 #define REG_ID     0x00  
7661 #define REG_VER    0x01  
7662 #define REG_TABLE  0x10  
7663 
7664 
7665 
7666 
7667 
7668 
7669 #define INT_DISABLED   0x00010000  
7670 #define INT_LEVEL      0x00008000  
7671 #define INT_ACTIVELOW  0x00002000  
7672 #define INT_LOGICAL    0x00000800  
7673 
7674 volatile struct ioapic *ioapic;
7675 
7676 
7677 struct ioapic {
7678   uint reg;
7679   uint pad[3];
7680   uint data;
7681 };
7682 
7683 static uint
7684 ioapicread(int reg)
7685 {
7686   ioapic->reg = reg;
7687   return ioapic->data;
7688 }
7689 
7690 static void
7691 ioapicwrite(int reg, uint data)
7692 {
7693   ioapic->reg = reg;
7694   ioapic->data = data;
7695 }
7696 
7697 
7698 
7699 
7700 void
7701 ioapicinit(void)
7702 {
7703   int i, id, maxintr;
7704 
7705   ioapic = (volatile struct ioapic*)IOAPIC;
7706   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
7707   id = ioapicread(REG_ID) >> 24;
7708   if(id != ioapicid)
7709     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
7710 
7711   
7712   
7713   for(i = 0; i <= maxintr; i++){
7714     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
7715     ioapicwrite(REG_TABLE+2*i+1, 0);
7716   }
7717 }
7718 
7719 void
7720 ioapicenable(int irq, int cpunum)
7721 {
7722   
7723   
7724   
7725   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
7726   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
7727 }
7728 
7729 
7730 
7731 
7732 
7733 
7734 
7735 
7736 
7737 
7738 
7739 
7740 
7741 
7742 
7743 
7744 
7745 
7746 
7747 
7748 
7749 
7750 
7751 
7752 #define KBSTATP         0x64    
7753 #define KBS_DIB         0x01    
7754 #define KBDATAP         0x60    
7755 
7756 #define NO              0
7757 
7758 #define SHIFT           (1<<0)
7759 #define CTL             (1<<1)
7760 #define ALT             (1<<2)
7761 
7762 #define CAPSLOCK        (1<<3)
7763 #define NUMLOCK         (1<<4)
7764 #define SCROLLLOCK      (1<<5)
7765 
7766 #define E0ESC           (1<<6)
7767 
7768 
7769 #define KEY_HOME        0xE0
7770 #define KEY_END         0xE1
7771 #define KEY_UP          0xE2
7772 #define KEY_DN          0xE3
7773 #define KEY_LF          0xE4
7774 #define KEY_RT          0xE5
7775 #define KEY_PGUP        0xE6
7776 #define KEY_PGDN        0xE7
7777 #define KEY_INS         0xE8
7778 #define KEY_DEL         0xE9
7779 
7780 
7781 #define C(x) (x - '@')
7782 
7783 static uchar shiftcode[256] =
7784 {
7785   [0x1D] CTL,
7786   [0x2A] SHIFT,
7787   [0x36] SHIFT,
7788   [0x38] ALT,
7789   [0x9D] CTL,
7790   [0xB8] ALT
7791 };
7792 
7793 static uchar togglecode[256] =
7794 {
7795   [0x3A] CAPSLOCK,
7796   [0x45] NUMLOCK,
7797   [0x46] SCROLLLOCK
7798 };
7799 
7800 static uchar normalmap[256] =
7801 {
7802   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
7803   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
7804   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
7805   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
7806   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
7807   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
7808   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
7809   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7810   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7811   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7812   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7813   [0x9C] '\n',      
7814   [0xB5] '/',       
7815   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7816   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7817   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7818   [0x97] KEY_HOME,  [0xCF] KEY_END,
7819   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7820 };
7821 
7822 static uchar shiftmap[256] =
7823 {
7824   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
7825   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
7826   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
7827   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
7828   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
7829   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
7830   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
7831   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
7832   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
7833   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
7834   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
7835   [0x9C] '\n',      
7836   [0xB5] '/',       
7837   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7838   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7839   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7840   [0x97] KEY_HOME,  [0xCF] KEY_END,
7841   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7842 };
7843 
7844 
7845 
7846 
7847 
7848 
7849 
7850 static uchar ctlmap[256] =
7851 {
7852   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7853   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
7854   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
7855   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
7856   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
7857   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
7858   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
7859   [0x9C] '\r',      
7860   [0xB5] C('/'),    
7861   [0xC8] KEY_UP,    [0xD0] KEY_DN,
7862   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
7863   [0xCB] KEY_LF,    [0xCD] KEY_RT,
7864   [0x97] KEY_HOME,  [0xCF] KEY_END,
7865   [0xD2] KEY_INS,   [0xD3] KEY_DEL
7866 };
7867 
7868 
7869 
7870 
7871 
7872 
7873 
7874 
7875 
7876 
7877 
7878 
7879 
7880 
7881 
7882 
7883 
7884 
7885 
7886 
7887 
7888 
7889 
7890 
7891 
7892 
7893 
7894 
7895 
7896 
7897 
7898 
7899 
7900 #include "types.h"
7901 #include "x86.h"
7902 #include "defs.h"
7903 #include "kbd.h"
7904 
7905 int
7906 kbdgetc(void)
7907 {
7908   static uint shift;
7909   static uchar *charcode[4] = {
7910     normalmap, shiftmap, ctlmap, ctlmap
7911   };
7912   uint st, data, c;
7913 
7914   st = inb(KBSTATP);
7915   if((st & KBS_DIB) == 0)
7916     return -1;
7917   data = inb(KBDATAP);
7918 
7919   if(data == 0xE0){
7920     shift |= E0ESC;
7921     return 0;
7922   } else if(data & 0x80){
7923     
7924     data = (shift & E0ESC ? data : data & 0x7F);
7925     shift &= ~(shiftcode[data] | E0ESC);
7926     return 0;
7927   } else if(shift & E0ESC){
7928     
7929     data |= 0x80;
7930     shift &= ~E0ESC;
7931   }
7932 
7933   shift |= shiftcode[data];
7934   shift ^= togglecode[data];
7935   c = charcode[shift & (CTL | SHIFT)][data];
7936   if(shift & CAPSLOCK){
7937     if('a' <= c && c <= 'z')
7938       c += 'A' - 'a';
7939     else if('A' <= c && c <= 'Z')
7940       c += 'a' - 'A';
7941   }
7942   return c;
7943 }
7944 
7945 void
7946 kbdintr(void)
7947 {
7948   consoleintr(kbdgetc);
7949 }
7950 
7951 
7952 
7953 
7954 #include "types.h"
7955 #include "defs.h"
7956 #include "param.h"
7957 #include "traps.h"
7958 #include "spinlock.h"
7959 #include "sleeplock.h"
7960 #include "fs.h"
7961 #include "file.h"
7962 #include "memlayout.h"
7963 #include "mmu.h"
7964 #include "proc.h"
7965 #include "x86.h"
7966 
7967 static void consputc(int);
7968 
7969 static int panicked = 0;
7970 
7971 static struct {
7972   struct spinlock lock;
7973   int locking;
7974 } cons;
7975 
7976 static void
7977 printint(int xx, int base, int sign)
7978 {
7979   static char digits[] = "0123456789abcdef";
7980   char buf[16];
7981   int i;
7982   uint x;
7983 
7984   if(sign && (sign = xx < 0))
7985     x = -xx;
7986   else
7987     x = xx;
7988 
7989   i = 0;
7990   do{
7991     buf[i++] = digits[x % base];
7992   }while((x /= base) != 0);
7993 
7994   if(sign)
7995     buf[i++] = '-';
7996 
7997   while(--i >= 0)
7998     consputc(buf[i]);
7999 }
8000 
8001 
8002 
8003 
8004 
8005 
8006 
8007 
8008 
8009 
8010 
8011 
8012 
8013 
8014 
8015 
8016 
8017 
8018 
8019 
8020 
8021 
8022 
8023 
8024 
8025 
8026 
8027 
8028 
8029 
8030 
8031 
8032 
8033 
8034 
8035 
8036 
8037 
8038 
8039 
8040 
8041 
8042 
8043 
8044 
8045 
8046 
8047 
8048 
8049 
8050 
8051 void
8052 cprintf(char *fmt, ...)
8053 {
8054   int i, c, locking;
8055   uint *argp;
8056   char *s;
8057 
8058   locking = cons.locking;
8059   if(locking)
8060     acquire(&cons.lock);
8061 
8062   if (fmt == 0)
8063     panic("null fmt");
8064 
8065   argp = (uint*)(void*)(&fmt + 1);
8066   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
8067     if(c != '%'){
8068       consputc(c);
8069       continue;
8070     }
8071     c = fmt[++i] & 0xff;
8072     if(c == 0)
8073       break;
8074     switch(c){
8075     case 'd':
8076       printint(*argp++, 10, 1);
8077       break;
8078     case 'x':
8079     case 'p':
8080       printint(*argp++, 16, 0);
8081       break;
8082     case 's':
8083       if((s = (char*)*argp++) == 0)
8084         s = "(null)";
8085       for(; *s; s++)
8086         consputc(*s);
8087       break;
8088     case '%':
8089       consputc('%');
8090       break;
8091     default:
8092       
8093       consputc('%');
8094       consputc(c);
8095       break;
8096     }
8097   }
8098 
8099 
8100   if(locking)
8101     release(&cons.lock);
8102 }
8103 
8104 void
8105 panic(char *s)
8106 {
8107   int i;
8108   uint pcs[10];
8109 
8110   cli();
8111   cons.locking = 0;
8112   
8113   cprintf("lapicid %d: panic: ", lapicid());
8114   cprintf(s);
8115   cprintf("\n");
8116   getcallerpcs(&s, pcs);
8117   for(i=0; i<10; i++)
8118     cprintf(" %p", pcs[i]);
8119   panicked = 1; 
8120   for(;;)
8121     ;
8122 }
8123 
8124 
8125 
8126 
8127 
8128 
8129 
8130 
8131 
8132 
8133 
8134 
8135 
8136 
8137 
8138 
8139 
8140 
8141 
8142 
8143 
8144 
8145 
8146 
8147 
8148 
8149 
8150 #define BACKSPACE 0x100
8151 #define CRTPORT 0x3d4
8152 static ushort *crt = (ushort*)P2V(0xb8000);  
8153 
8154 static void
8155 cgaputc(int c)
8156 {
8157   int pos;
8158 
8159   
8160   outb(CRTPORT, 14);
8161   pos = inb(CRTPORT+1) << 8;
8162   outb(CRTPORT, 15);
8163   pos |= inb(CRTPORT+1);
8164 
8165   if(c == '\n')
8166     pos += 80 - pos%80;
8167   else if(c == BACKSPACE){
8168     if(pos > 0) --pos;
8169   } else
8170     crt[pos++] = (c&0xff) | 0x0700;  
8171 
8172   if(pos < 0 || pos > 25*80)
8173     panic("pos under/overflow");
8174 
8175   if((pos/80) >= 24){  
8176     memmove(crt, crt+80, sizeof(crt[0])*23*80);
8177     pos -= 80;
8178     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
8179   }
8180 
8181   outb(CRTPORT, 14);
8182   outb(CRTPORT+1, pos>>8);
8183   outb(CRTPORT, 15);
8184   outb(CRTPORT+1, pos);
8185   crt[pos] = ' ' | 0x0700;
8186 }
8187 
8188 
8189 
8190 
8191 
8192 
8193 
8194 
8195 
8196 
8197 
8198 
8199 
8200 void
8201 consputc(int c)
8202 {
8203   if(panicked){
8204     cli();
8205     for(;;)
8206       ;
8207   }
8208 
8209   if(c == BACKSPACE){
8210     uartputc('\b'); uartputc(' '); uartputc('\b');
8211   } else
8212     uartputc(c);
8213   cgaputc(c);
8214 }
8215 
8216 #define INPUT_BUF 128
8217 struct {
8218   char buf[INPUT_BUF];
8219   uint r;  
8220   uint w;  
8221   uint e;  
8222 } input;
8223 
8224 #define C(x)  ((x)-'@')  
8225 
8226 void
8227 consoleintr(int (*getc)(void))
8228 {
8229   int c, doprocdump = 0;
8230 
8231   acquire(&cons.lock);
8232   while((c = getc()) >= 0){
8233     switch(c){
8234     case C('P'):  
8235       
8236       doprocdump = 1;
8237       break;
8238     case C('U'):  
8239       while(input.e != input.w &&
8240             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
8241         input.e--;
8242         consputc(BACKSPACE);
8243       }
8244       break;
8245     case C('H'): case '\x7f':  
8246       if(input.e != input.w){
8247         input.e--;
8248         consputc(BACKSPACE);
8249       }
8250       break;
8251     default:
8252       if(c != 0 && input.e-input.r < INPUT_BUF){
8253         c = (c == '\r') ? '\n' : c;
8254         input.buf[input.e++ % INPUT_BUF] = c;
8255         consputc(c);
8256         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
8257           input.w = input.e;
8258           wakeup(&input.r);
8259         }
8260       }
8261       break;
8262     }
8263   }
8264   release(&cons.lock);
8265   if(doprocdump) {
8266     procdump();  
8267   }
8268 }
8269 
8270 int
8271 consoleread(struct inode *ip, char *dst, int n)
8272 {
8273   uint target;
8274   int c;
8275 
8276   iunlock(ip);
8277   target = n;
8278   acquire(&cons.lock);
8279   while(n > 0){
8280     while(input.r == input.w){
8281       if(myproc()->killed){
8282         release(&cons.lock);
8283         ilock(ip);
8284         return -1;
8285       }
8286       sleep(&input.r, &cons.lock);
8287     }
8288     c = input.buf[input.r++ % INPUT_BUF];
8289     if(c == C('D')){  
8290       if(n < target){
8291         
8292         
8293         input.r--;
8294       }
8295       break;
8296     }
8297     *dst++ = c;
8298     --n;
8299     if(c == '\n')
8300       break;
8301   }
8302   release(&cons.lock);
8303   ilock(ip);
8304 
8305   return target - n;
8306 }
8307 
8308 int
8309 consolewrite(struct inode *ip, char *buf, int n)
8310 {
8311   int i;
8312 
8313   iunlock(ip);
8314   acquire(&cons.lock);
8315   for(i = 0; i < n; i++)
8316     consputc(buf[i] & 0xff);
8317   release(&cons.lock);
8318   ilock(ip);
8319 
8320   return n;
8321 }
8322 
8323 void
8324 consoleinit(void)
8325 {
8326   initlock(&cons.lock, "console");
8327 
8328   devsw[CONSOLE].write = consolewrite;
8329   devsw[CONSOLE].read = consoleread;
8330   cons.locking = 1;
8331 
8332   ioapicenable(IRQ_KBD, 0);
8333 }
8334 
8335 
8336 
8337 
8338 
8339 
8340 
8341 
8342 
8343 
8344 
8345 
8346 
8347 
8348 
8349 
8350 
8351 
8352 #include "types.h"
8353 #include "defs.h"
8354 #include "param.h"
8355 #include "traps.h"
8356 #include "spinlock.h"
8357 #include "sleeplock.h"
8358 #include "fs.h"
8359 #include "file.h"
8360 #include "mmu.h"
8361 #include "proc.h"
8362 #include "x86.h"
8363 
8364 #define COM1    0x3f8
8365 
8366 static int uart;    
8367 
8368 void
8369 uartinit(void)
8370 {
8371   char *p;
8372 
8373   
8374   outb(COM1+2, 0);
8375 
8376   
8377   outb(COM1+3, 0x80);    
8378   outb(COM1+0, 115200/9600);
8379   outb(COM1+1, 0);
8380   outb(COM1+3, 0x03);    
8381   outb(COM1+4, 0);
8382   outb(COM1+1, 0x01);    
8383 
8384   
8385   if(inb(COM1+5) == 0xFF)
8386     return;
8387   uart = 1;
8388 
8389   
8390   
8391   inb(COM1+2);
8392   inb(COM1+0);
8393   ioapicenable(IRQ_COM1, 0);
8394 
8395   
8396   for(p="xv6...\n"; *p; p++)
8397     uartputc(*p);
8398 }
8399 
8400 void
8401 uartputc(int c)
8402 {
8403   int i;
8404 
8405   if(!uart)
8406     return;
8407   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
8408     microdelay(10);
8409   outb(COM1+0, c);
8410 }
8411 
8412 static int
8413 uartgetc(void)
8414 {
8415   if(!uart)
8416     return -1;
8417   if(!(inb(COM1+5) & 0x01))
8418     return -1;
8419   return inb(COM1+0);
8420 }
8421 
8422 void
8423 uartintr(void)
8424 {
8425   consoleintr(uartgetc);
8426 }
8427 
8428 
8429 
8430 
8431 
8432 
8433 
8434 
8435 
8436 
8437 
8438 
8439 
8440 
8441 
8442 
8443 
8444 
8445 
8446 
8447 
8448 
8449 
8450 
8451 
8452 
8453 
8454 
8455 
8456 
8457 
8458 .globl start
8459 start:
8460   pushl $argv
8461   pushl $init
8462   pushl $0  
8463   movl $SYS_exec, %eax
8464   int $T_SYSCALL
8465 
8466 
8467 exit:
8468   movl $SYS_exit, %eax
8469   int $T_SYSCALL
8470   jmp exit
8471 
8472 
8473 init:
8474   .string "/init\0"
8475 
8476 
8477 .p2align 2
8478 argv:
8479   .long init
8480   .long 0
8481 
8482 
8483 
8484 
8485 
8486 
8487 
8488 
8489 
8490 
8491 
8492 
8493 
8494 
8495 
8496 
8497 
8498 
8499 
8500 
8501 
8502 
8503 
8504   .globl name; \
8505   name: \
8506     movl $SYS_ 
8507     int $T_SYSCALL; \
8508     ret
8509 
8510 SYSCALL(fork)
8511 SYSCALL(exit)
8512 SYSCALL(wait)
8513 SYSCALL(pipe)
8514 SYSCALL(read)
8515 SYSCALL(write)
8516 SYSCALL(close)
8517 SYSCALL(kill)
8518 SYSCALL(exec)
8519 SYSCALL(open)
8520 SYSCALL(mknod)
8521 SYSCALL(unlink)
8522 SYSCALL(fstat)
8523 SYSCALL(link)
8524 SYSCALL(mkdir)
8525 SYSCALL(chdir)
8526 SYSCALL(dup)
8527 SYSCALL(getpid)
8528 SYSCALL(sbrk)
8529 SYSCALL(sleep)
8530 SYSCALL(uptime)
8531 SYSCALL(head)
8532 SYSCALL(uniq)
8533 
8534 
8535 
8536 
8537 
8538 
8539 
8540 
8541 
8542 
8543 
8544 
8545 
8546 
8547 
8548 
8549 
8550 
8551 
8552 #include "types.h"
8553 #include "stat.h"
8554 #include "user.h"
8555 #include "fcntl.h"
8556 
8557 char *argv[] = { "sh", 0 };
8558 
8559 int
8560 main(void)
8561 {
8562   int pid, wpid;
8563 
8564   if(open("console", O_RDWR) < 0){
8565     mknod("console", 1, 1);
8566     open("console", O_RDWR);
8567   }
8568   dup(0);  
8569   dup(0);  
8570 
8571   for(;;){
8572     printf(1, "init: starting sh\n");
8573     pid = fork();
8574     if(pid < 0){
8575       printf(1, "init: fork failed\n");
8576       exit();
8577     }
8578     if(pid == 0){
8579       exec("sh", argv);
8580       printf(1, "init: exec sh failed\n");
8581       exit();
8582     }
8583     while((wpid=wait()) >= 0 && wpid != pid)
8584       printf(1, "zombie!\n");
8585   }
8586 }
8587 
8588 
8589 
8590 
8591 
8592 
8593 
8594 
8595 
8596 
8597 
8598 
8599 
8600 
8601 
8602 #include "types.h"
8603 #include "user.h"
8604 #include "fcntl.h"
8605 
8606 
8607 #define EXEC  1
8608 #define REDIR 2
8609 #define PIPE  3
8610 #define LIST  4
8611 #define BACK  5
8612 
8613 #define MAXARGS 10
8614 
8615 struct cmd {
8616   int type;
8617 };
8618 
8619 struct execcmd {
8620   int type;
8621   char *argv[MAXARGS];
8622   char *eargv[MAXARGS];
8623 };
8624 
8625 struct redircmd {
8626   int type;
8627   struct cmd *cmd;
8628   char *file;
8629   char *efile;
8630   int mode;
8631   int fd;
8632 };
8633 
8634 struct pipecmd {
8635   int type;
8636   struct cmd *left;
8637   struct cmd *right;
8638 };
8639 
8640 struct listcmd {
8641   int type;
8642   struct cmd *left;
8643   struct cmd *right;
8644 };
8645 
8646 struct backcmd {
8647   int type;
8648   struct cmd *cmd;
8649 };
8650 int fork1(void);  
8651 void panic(char*);
8652 struct cmd *parsecmd(char*);
8653 
8654 
8655 void
8656 runcmd(struct cmd *cmd)
8657 {
8658   int p[2];
8659   struct backcmd *bcmd;
8660   struct execcmd *ecmd;
8661   struct listcmd *lcmd;
8662   struct pipecmd *pcmd;
8663   struct redircmd *rcmd;
8664 
8665   if(cmd == 0)
8666     exit();
8667 
8668   switch(cmd->type){
8669   default:
8670     panic("runcmd");
8671 
8672   case EXEC:
8673     ecmd = (struct execcmd*)cmd;
8674     if(ecmd->argv[0] == 0)
8675       exit();
8676     exec(ecmd->argv[0], ecmd->argv);
8677     printf(2, "exec %s failed\n", ecmd->argv[0]);
8678     break;
8679 
8680   case REDIR:
8681     rcmd = (struct redircmd*)cmd;
8682     close(rcmd->fd);
8683     if(open(rcmd->file, rcmd->mode) < 0){
8684       printf(2, "open %s failed\n", rcmd->file);
8685       exit();
8686     }
8687     runcmd(rcmd->cmd);
8688     break;
8689 
8690   case LIST:
8691     lcmd = (struct listcmd*)cmd;
8692     if(fork1() == 0)
8693       runcmd(lcmd->left);
8694     wait();
8695     runcmd(lcmd->right);
8696     break;
8697 
8698 
8699 
8700   case PIPE:
8701     pcmd = (struct pipecmd*)cmd;
8702     if(pipe(p) < 0)
8703       panic("pipe");
8704     if(fork1() == 0){
8705       close(1);
8706       dup(p[1]);
8707       close(p[0]);
8708       close(p[1]);
8709       runcmd(pcmd->left);
8710     }
8711     if(fork1() == 0){
8712       close(0);
8713       dup(p[0]);
8714       close(p[0]);
8715       close(p[1]);
8716       runcmd(pcmd->right);
8717     }
8718     close(p[0]);
8719     close(p[1]);
8720     wait();
8721     wait();
8722     break;
8723 
8724   case BACK:
8725     bcmd = (struct backcmd*)cmd;
8726     if(fork1() == 0)
8727       runcmd(bcmd->cmd);
8728     break;
8729   }
8730   exit();
8731 }
8732 
8733 int
8734 getcmd(char *buf, int nbuf)
8735 {
8736   printf(2, "$ ");
8737   memset(buf, 0, nbuf);
8738   gets(buf, nbuf);
8739   if(buf[0] == 0) 
8740     return -1;
8741   return 0;
8742 }
8743 
8744 
8745 
8746 
8747 
8748 
8749 
8750 int
8751 main(void)
8752 {
8753   static char buf[100];
8754   int fd;
8755 
8756   
8757   while((fd = open("console", O_RDWR)) >= 0){
8758     if(fd >= 3){
8759       close(fd);
8760       break;
8761     }
8762   }
8763 
8764   
8765   while(getcmd(buf, sizeof(buf)) >= 0){
8766     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
8767       
8768       buf[strlen(buf)-1] = 0;  
8769       if(chdir(buf+3) < 0)
8770         printf(2, "cannot cd %s\n", buf+3);
8771       continue;
8772     }
8773     if(fork1() == 0)
8774       runcmd(parsecmd(buf));
8775     wait();
8776   }
8777   exit();
8778 }
8779 
8780 void
8781 panic(char *s)
8782 {
8783   printf(2, "%s\n", s);
8784   exit();
8785 }
8786 
8787 int
8788 fork1(void)
8789 {
8790   int pid;
8791 
8792   pid = fork();
8793   if(pid == -1)
8794     panic("fork");
8795   return pid;
8796 }
8797 
8798 
8799 
8800 
8801 
8802 struct cmd*
8803 execcmd(void)
8804 {
8805   struct execcmd *cmd;
8806 
8807   cmd = malloc(sizeof(*cmd));
8808   memset(cmd, 0, sizeof(*cmd));
8809   cmd->type = EXEC;
8810   return (struct cmd*)cmd;
8811 }
8812 
8813 struct cmd*
8814 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
8815 {
8816   struct redircmd *cmd;
8817 
8818   cmd = malloc(sizeof(*cmd));
8819   memset(cmd, 0, sizeof(*cmd));
8820   cmd->type = REDIR;
8821   cmd->cmd = subcmd;
8822   cmd->file = file;
8823   cmd->efile = efile;
8824   cmd->mode = mode;
8825   cmd->fd = fd;
8826   return (struct cmd*)cmd;
8827 }
8828 
8829 struct cmd*
8830 pipecmd(struct cmd *left, struct cmd *right)
8831 {
8832   struct pipecmd *cmd;
8833 
8834   cmd = malloc(sizeof(*cmd));
8835   memset(cmd, 0, sizeof(*cmd));
8836   cmd->type = PIPE;
8837   cmd->left = left;
8838   cmd->right = right;
8839   return (struct cmd*)cmd;
8840 }
8841 
8842 
8843 
8844 
8845 
8846 
8847 
8848 
8849 
8850 struct cmd*
8851 listcmd(struct cmd *left, struct cmd *right)
8852 {
8853   struct listcmd *cmd;
8854 
8855   cmd = malloc(sizeof(*cmd));
8856   memset(cmd, 0, sizeof(*cmd));
8857   cmd->type = LIST;
8858   cmd->left = left;
8859   cmd->right = right;
8860   return (struct cmd*)cmd;
8861 }
8862 
8863 struct cmd*
8864 backcmd(struct cmd *subcmd)
8865 {
8866   struct backcmd *cmd;
8867 
8868   cmd = malloc(sizeof(*cmd));
8869   memset(cmd, 0, sizeof(*cmd));
8870   cmd->type = BACK;
8871   cmd->cmd = subcmd;
8872   return (struct cmd*)cmd;
8873 }
8874 
8875 
8876 
8877 
8878 
8879 
8880 
8881 
8882 
8883 
8884 
8885 
8886 
8887 
8888 
8889 
8890 
8891 
8892 
8893 
8894 
8895 
8896 
8897 
8898 
8899 
8900 
8901 
8902 char whitespace[] = " \t\r\n\v";
8903 char symbols[] = "<|>&;()";
8904 
8905 int
8906 gettoken(char **ps, char *es, char **q, char **eq)
8907 {
8908   char *s;
8909   int ret;
8910 
8911   s = *ps;
8912   while(s < es && strchr(whitespace, *s))
8913     s++;
8914   if(q)
8915     *q = s;
8916   ret = *s;
8917   switch(*s){
8918   case 0:
8919     break;
8920   case '|':
8921   case '(':
8922   case ')':
8923   case ';':
8924   case '&':
8925   case '<':
8926     s++;
8927     break;
8928   case '>':
8929     s++;
8930     if(*s == '>'){
8931       ret = '+';
8932       s++;
8933     }
8934     break;
8935   default:
8936     ret = 'a';
8937     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
8938       s++;
8939     break;
8940   }
8941   if(eq)
8942     *eq = s;
8943 
8944   while(s < es && strchr(whitespace, *s))
8945     s++;
8946   *ps = s;
8947   return ret;
8948 }
8949 
8950 int
8951 peek(char **ps, char *es, char *toks)
8952 {
8953   char *s;
8954 
8955   s = *ps;
8956   while(s < es && strchr(whitespace, *s))
8957     s++;
8958   *ps = s;
8959   return *s && strchr(toks, *s);
8960 }
8961 
8962 struct cmd *parseline(char**, char*);
8963 struct cmd *parsepipe(char**, char*);
8964 struct cmd *parseexec(char**, char*);
8965 struct cmd *nulterminate(struct cmd*);
8966 
8967 struct cmd*
8968 parsecmd(char *s)
8969 {
8970   char *es;
8971   struct cmd *cmd;
8972 
8973   es = s + strlen(s);
8974   cmd = parseline(&s, es);
8975   peek(&s, es, "");
8976   if(s != es){
8977     printf(2, "leftovers: %s\n", s);
8978     panic("syntax");
8979   }
8980   nulterminate(cmd);
8981   return cmd;
8982 }
8983 
8984 struct cmd*
8985 parseline(char **ps, char *es)
8986 {
8987   struct cmd *cmd;
8988 
8989   cmd = parsepipe(ps, es);
8990   while(peek(ps, es, "&")){
8991     gettoken(ps, es, 0, 0);
8992     cmd = backcmd(cmd);
8993   }
8994   if(peek(ps, es, ";")){
8995     gettoken(ps, es, 0, 0);
8996     cmd = listcmd(cmd, parseline(ps, es));
8997   }
8998   return cmd;
8999 }
9000 struct cmd*
9001 parsepipe(char **ps, char *es)
9002 {
9003   struct cmd *cmd;
9004 
9005   cmd = parseexec(ps, es);
9006   if(peek(ps, es, "|")){
9007     gettoken(ps, es, 0, 0);
9008     cmd = pipecmd(cmd, parsepipe(ps, es));
9009   }
9010   return cmd;
9011 }
9012 
9013 struct cmd*
9014 parseredirs(struct cmd *cmd, char **ps, char *es)
9015 {
9016   int tok;
9017   char *q, *eq;
9018 
9019   while(peek(ps, es, "<>")){
9020     tok = gettoken(ps, es, 0, 0);
9021     if(gettoken(ps, es, &q, &eq) != 'a')
9022       panic("missing file for redirection");
9023     switch(tok){
9024     case '<':
9025       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
9026       break;
9027     case '>':
9028       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9029       break;
9030     case '+':  
9031       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9032       break;
9033     }
9034   }
9035   return cmd;
9036 }
9037 
9038 
9039 
9040 
9041 
9042 
9043 
9044 
9045 
9046 
9047 
9048 
9049 
9050 struct cmd*
9051 parseblock(char **ps, char *es)
9052 {
9053   struct cmd *cmd;
9054 
9055   if(!peek(ps, es, "("))
9056     panic("parseblock");
9057   gettoken(ps, es, 0, 0);
9058   cmd = parseline(ps, es);
9059   if(!peek(ps, es, ")"))
9060     panic("syntax - missing )");
9061   gettoken(ps, es, 0, 0);
9062   cmd = parseredirs(cmd, ps, es);
9063   return cmd;
9064 }
9065 
9066 struct cmd*
9067 parseexec(char **ps, char *es)
9068 {
9069   char *q, *eq;
9070   int tok, argc;
9071   struct execcmd *cmd;
9072   struct cmd *ret;
9073 
9074   if(peek(ps, es, "("))
9075     return parseblock(ps, es);
9076 
9077   ret = execcmd();
9078   cmd = (struct execcmd*)ret;
9079 
9080   argc = 0;
9081   ret = parseredirs(ret, ps, es);
9082   while(!peek(ps, es, "|)&;")){
9083     if((tok=gettoken(ps, es, &q, &eq)) == 0)
9084       break;
9085     if(tok != 'a')
9086       panic("syntax");
9087     cmd->argv[argc] = q;
9088     cmd->eargv[argc] = eq;
9089     argc++;
9090     if(argc >= MAXARGS)
9091       panic("too many args");
9092     ret = parseredirs(ret, ps, es);
9093   }
9094   cmd->argv[argc] = 0;
9095   cmd->eargv[argc] = 0;
9096   return ret;
9097 }
9098 
9099 
9100 
9101 struct cmd*
9102 nulterminate(struct cmd *cmd)
9103 {
9104   int i;
9105   struct backcmd *bcmd;
9106   struct execcmd *ecmd;
9107   struct listcmd *lcmd;
9108   struct pipecmd *pcmd;
9109   struct redircmd *rcmd;
9110 
9111   if(cmd == 0)
9112     return 0;
9113 
9114   switch(cmd->type){
9115   case EXEC:
9116     ecmd = (struct execcmd*)cmd;
9117     for(i=0; ecmd->argv[i]; i++)
9118       *ecmd->eargv[i] = 0;
9119     break;
9120 
9121   case REDIR:
9122     rcmd = (struct redircmd*)cmd;
9123     nulterminate(rcmd->cmd);
9124     *rcmd->efile = 0;
9125     break;
9126 
9127   case PIPE:
9128     pcmd = (struct pipecmd*)cmd;
9129     nulterminate(pcmd->left);
9130     nulterminate(pcmd->right);
9131     break;
9132 
9133   case LIST:
9134     lcmd = (struct listcmd*)cmd;
9135     nulterminate(lcmd->left);
9136     nulterminate(lcmd->right);
9137     break;
9138 
9139   case BACK:
9140     bcmd = (struct backcmd*)cmd;
9141     nulterminate(bcmd->cmd);
9142     break;
9143   }
9144   return cmd;
9145 }
9146 
9147 
9148 
9149 
9150 
9151 
9152 
9153 
9154 
9155 
9156 
9157 
9158 
9159 .code16                       
9160 .globl start
9161 start:
9162   cli                         
9163 
9164   
9165   xorw    %ax,%ax             
9166   movw    %ax,%ds             
9167   movw    %ax,%es             
9168   movw    %ax,%ss             
9169 
9170   
9171   
9172 seta20.1:
9173   inb     $0x64,%al               
9174   testb   $0x2,%al
9175   jnz     seta20.1
9176 
9177   movb    $0xd1,%al               
9178   outb    %al,$0x64
9179 
9180 seta20.2:
9181   inb     $0x64,%al               
9182   testb   $0x2,%al
9183   jnz     seta20.2
9184 
9185   movb    $0xdf,%al               
9186   outb    %al,$0x60
9187 
9188   
9189   
9190   
9191   lgdt    gdtdesc
9192   movl    %cr0, %eax
9193   orl     $CR0_PE, %eax
9194   movl    %eax, %cr0
9195 
9196 
9197 
9198 
9199 
9200   
9201   
9202   
9203   ljmp    $(SEG_KCODE<<3), $start32
9204 
9205 .code32  
9206 start32:
9207   
9208   movw    $(SEG_KDATA<<3), %ax    
9209   movw    %ax, %ds                
9210   movw    %ax, %es                
9211   movw    %ax, %ss                
9212   movw    $0, %ax                 
9213   movw    %ax, %fs                
9214   movw    %ax, %gs                
9215 
9216   
9217   movl    $start, %esp
9218   call    bootmain
9219 
9220   
9221   
9222   movw    $0x8a00, %ax            
9223   movw    %ax, %dx
9224   outw    %ax, %dx
9225   movw    $0x8ae0, %ax            
9226   outw    %ax, %dx
9227 spin:
9228   jmp     spin
9229 
9230 
9231 .p2align 2                                
9232 gdt:
9233   SEG_NULLASM                             
9234   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
9235   SEG_ASM(STA_W, 0x0, 0xffffffff)         
9236 
9237 gdtdesc:
9238   .word   (gdtdesc - gdt - 1)             
9239   .long   gdt                             
9240 
9241 
9242 
9243 
9244 
9245 
9246 
9247 
9248 
9249 
9250 
9251 
9252 
9253 
9254 
9255 
9256 
9257 #include "types.h"
9258 #include "elf.h"
9259 #include "x86.h"
9260 #include "memlayout.h"
9261 
9262 #define SECTSIZE  512
9263 
9264 void readseg(uchar*, uint, uint);
9265 
9266 void
9267 bootmain(void)
9268 {
9269   struct elfhdr *elf;
9270   struct proghdr *ph, *eph;
9271   void (*entry)(void);
9272   uchar* pa;
9273 
9274   elf = (struct elfhdr*)0x10000;  
9275 
9276   
9277   readseg((uchar*)elf, 4096, 0);
9278 
9279   
9280   if(elf->magic != ELF_MAGIC)
9281     return;  
9282 
9283   
9284   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
9285   eph = ph + elf->phnum;
9286   for(; ph < eph; ph++){
9287     pa = (uchar*)ph->paddr;
9288     readseg(pa, ph->filesz, ph->off);
9289     if(ph->memsz > ph->filesz)
9290       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
9291   }
9292 
9293   
9294   
9295   entry = (void(*)(void))(elf->entry);
9296   entry();
9297 }
9298 
9299 
9300 void
9301 waitdisk(void)
9302 {
9303   
9304   while((inb(0x1F7) & 0xC0) != 0x40)
9305     ;
9306 }
9307 
9308 
9309 void
9310 readsect(void *dst, uint offset)
9311 {
9312   
9313   waitdisk();
9314   outb(0x1F2, 1);   
9315   outb(0x1F3, offset);
9316   outb(0x1F4, offset >> 8);
9317   outb(0x1F5, offset >> 16);
9318   outb(0x1F6, (offset >> 24) | 0xE0);
9319   outb(0x1F7, 0x20);  
9320 
9321   
9322   waitdisk();
9323   insl(0x1F0, dst, SECTSIZE/4);
9324 }
9325 
9326 
9327 
9328 void
9329 readseg(uchar* pa, uint count, uint offset)
9330 {
9331   uchar* epa;
9332 
9333   epa = pa + count;
9334 
9335   
9336   pa -= offset % SECTSIZE;
9337 
9338   
9339   offset = (offset / SECTSIZE) + 1;
9340 
9341   
9342   
9343   
9344   for(; pa < epa; pa += SECTSIZE, offset++)
9345     readsect(pa, offset);
9346 }
9347 
9348 
9349 
9350 /* Simple linker script for the JOS kernel.
9351    See the GNU ld 'info' manual ("info ld") to learn the syntax. */
9352 
9353 OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
9354 OUTPUT_ARCH(i386)
9355 ENTRY(_start)
9356 
9357 SECTIONS
9358 {
9359 	/* Link the kernel at this address: "." means the current address */
9360         /* Must be equal to KERNLINK */
9361 	. = 0x80100000;
9362 
9363 	.text : AT(0x100000) {
9364 		*(.text .stub .text.* .gnu.linkonce.t.*)
9365 	}
9366 
9367 	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
9368 
9369 	.rodata : {
9370 		*(.rodata .rodata.* .gnu.linkonce.r.*)
9371 	}
9372 
9373 	/* Include debugging information in kernel memory */
9374 	.stab : {
9375 		PROVIDE(__STAB_BEGIN__ = .);
9376 		*(.stab);
9377 		PROVIDE(__STAB_END__ = .);
9378 	}
9379 
9380 	.stabstr : {
9381 		PROVIDE(__STABSTR_BEGIN__ = .);
9382 		*(.stabstr);
9383 		PROVIDE(__STABSTR_END__ = .);
9384 	}
9385 
9386 	/* Adjust the address for the data segment to the next page */
9387 	. = ALIGN(0x1000);
9388 
9389 	/* Conventionally, Unix linkers provide pseudo-symbols
9390 	 * etext, edata, and end, at the end of the text, data, and bss.
9391 	 * For the kernel mapping, we need the address at the beginning
9392 	 * of the data section, but that's not one of the conventional
9393 	 * symbols, because the convention started before there was a
9394 	 * read-only rodata section between text and data. */
9395 	PROVIDE(data = .);
9396 
9397 
9398 
9399 
9400 	/* The data segment */
9401 	.data : {
9402 		*(.data)
9403 	}
9404 
9405 	PROVIDE(edata = .);
9406 
9407 	.bss : {
9408 		*(.bss)
9409 	}
9410 
9411 	PROVIDE(end = .);
9412 
9413 	/DISCARD/ : {
9414 		*(.eh_frame .note.GNU-stack)
9415 	}
9416 }
9417 
9418 
9419 
9420 
9421 
9422 
9423 
9424 
9425 
9426 
9427 
9428 
9429 
9430 
9431 
9432 
9433 
9434 
9435 
9436 
9437 
9438 
9439 
9440 
9441 
9442 
9443 
9444 
9445 
9446 
9447 
9448 
9449 
